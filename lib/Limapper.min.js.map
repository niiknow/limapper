{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///Limapper.min.js","webpack:///webpack/bootstrap 3cf20a5263f2f54c6d08","webpack:///external \"L\"","webpack:///./src/index.js","webpack:///./~/leaflet-editable/src/Leaflet.Editable.js","webpack:///./~/leaflet.path.drag/src/Path.Drag.js"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_0__","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","_interopRequireDefault","obj","default","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","length","descriptor","writable","key","protoProps","staticProps","_leaflet","_leaflet2","Limapper","_name","opts","self","defs","minZoom","maxZoom","center","zoom","editable","crs","CRS","Simple","southWest","northEast","bounds","map","k","elid","unproject","imageHeight","imageWidth","LatLngBounds","imageOverlay","imageUrl","addTo","setMaxBounds","_map","EditControl","Control","extend","options","position","callback","kind","html","onAdd","container","DomUtil","create","link","href","title","innerHTML","DomEvent","on","stop","window","LAYER","editTools","e","layer","Path","setTimeout","items","NewRectangleControl","startRectangle","addControl","po","latLngToLayerPoint","LatLng","eachLayer","v","editor","Editable","RectangleEditor","_bounds","mydata","rect","nw","getNorthWest","se","getSouthEast","x1","x","x2","y1","y","y2","push","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","undefined","apply","L","Evented","statics","FORWARD","BACKWARD","zIndex","polygonClass","Polygon","polylineClass","Polyline","markerClass","Marker","rectangleClass","Rectangle","circleClass","Circle","drawingCSSClass","drawingCursor","editLayer","featuresLayer","polylineEditorClass","polygonEditorClass","markerEditorClass","rectangleEditorClass","circleEditorClass","lineGuideOptions","skipMiddleMarkers","initialize","setOptions","_lastZIndex","createEditLayer","createFeaturesLayer","forwardLineGuide","createLineGuide","backwardLineGuide","fireAndForward","type","fire","dashArray","weight","interactive","polyline","createVertexIcon","Browser","touch","TouchVertexIcon","VertexIcon","LayerGroup","moveForwardLineGuide","latlng","_latlngs","redraw","moveBackwardLineGuide","anchorForwardLineGuide","anchorBackwardLineGuide","attachForwardLineGuide","addLayer","attachBackwardLineGuide","detachForwardLineGuide","setLatLngs","removeLayer","detachBackwardLineGuide","blockEvents","_oldTargets","_targets","unblockEvents","registerForDrawing","_drawingEditor","unregisterForDrawing","reset","onDrawingMouseMove","onMousedown","onMouseup","addClass","_container","defaultMapCursor","style","cursor","removeClass","off","_drawing","cancelDrawing","_mouseDown","onDrawingMouseDown","mouseDown","onDrawingMouseUp","origin","point","originalEvent","clientX","clientY","distance","distanceTo","Math","abs","devicePixelRatio","onDrawingClick","drawing","stopDrawing","commitDrawing","connectCreatedToMap","startPolyline","line","createPolyline","enableEdit","newShape","startPolygon","polygon","createPolygon","startMarker","getCenter","clone","marker","createMarker","startDrawing","corner","latLng","rectangle","createRectangle","startCircle","circle","createCircle","startHole","newHole","createLayer","klass","latlngs","Util","editOptions","makeCancellable","cancel","_cancelled","Map","mergeOptions","editToolsClass","addInitHook","whenReady","DivIcon","iconSize","Point","VertexMarker","draggable","className","icon","tools","__vertex","setZIndexOffset","onDrag","onDragStart","onDragEnd","onClick","onContextMenu","onMouseDown","addMiddleMarkers","onRemove","middleMarker","delete","vertex","onVertexMarkerDrag","iconPos","getPosition","_icon","layerPointToLatLng","update","_latlng","refresh","updateLatLng","next","getNext","onVertexMarkerDragStart","onVertexMarkerDragEnd","onVertexMarkerClick","onVertexMarkerContextMenu","onVertexMarkerMouseDown","splice","getIndex","onVertexDeleted","deleteShape","resetMiddleMarker","indexOf","getLastIndex","getPrevious","index","previousIndex","CLOSED","previous","nextIndex","addMiddleMarker","hasMiddleMarkers","split","splitShape","continue","continueBackward","continueForward","vertexMarkerClass","MiddleMarker","opacity","left","right","computeLatLng","_opacity","setVisibility","leftPoint","latLngToContainerPoint","rightPoint","size","hide","show","setOpacity","setLatLng","containerPointToLatLng","onMiddleMarkerMouseDown","addVertexMarker","parent","parentNode","removeChild","appendChild","_initIcon","_initInteraction","Draggable","_dragging","dragging","_draggable","_onDown","middleMarkerClass","BaseEditor","Handler","feature","addHooks","isConnected","onFeatureAdd","once","onEnable","_getEvents","removeHooks","disable","clearLayers","onDisable","enable","onEditing","onStartDrawing","onEndDrawing","onCancelDrawing","onCommitDrawing","endDrawing","connect","processDrawingClick","hasLayer","onMove","dragstart","drag","dragend","remove","MarkerEditor","PathEditor","MIN_VERTEX","initVertexMarkers","enabled","getLatLngs","_flat","addVertexMarkers","refreshVertexMarkers","getDefaultLatLngs","commit","ctrlKey","onVertexMarkerCtrlClick","altKey","onVertexMarkerAltClick","shiftKey","onVertexMarkerShiftClick","metaKey","onVertexMarkerMetaKeyClick","_drawnLatLngs","onVertexRawMarkerClick","vertexCanBeDeleted","extendBounds","setDrawnLatLngs","startDrawingForward","addLatLng","unshift","newPointForward","newPointBackward","console","error","removeLatLng","pop","shape","addNewEmptyShape","_deleteShape","ensureNotFlat","inplaceDelete","Number","MAX_VALUE","spliceDelete","deleteShapeAt","shapeAt","appendShape","insertShape","prependShape","ensureMulti","formatShape","_enabled","PolylineEditor","startDrawingBackward","shapeIndex","first","slice","second","lat","lng","alt","PolygonEditor","addNewEmptyHole","holes","parentShape","oppositeIndex","opposite","updateBounds","updateLatLngs","_simulated","_onUp","newLatlngs","_boundsToLatLngs","CircleEditor","_resizeLatLng","computeResizeLatLng","delta","_radius","_mRadius","cos","PI","project","updateResizeLatLng","resize","radius","setRadius","EditableMixin","createEditor","Error","editorClass","getEditorClass","editEnabled","disableEdit","toggleEdit","_onEditableAdd","PolylineMixin","isInLatLngs","len","part","w","_clickTolerance","_projectLatlngs","_pxBounds","contains","LineUtil","pointToSegmentDistance","PolygonMixin","l1","l2","j","len2","inside","idx","MarkerMixin","RectangleMixin","CircleMixin","keepEditable","include","PathDraggable","path","_path","_canvas","getRenderer","Canvas","element","_updatePosition","_lastEvent","touches","_startPoint","_containsPoint","mouseEventToLayerPoint","PathDrag","getEvents","_onDragStart","_onDrag","_onDragEnd","_element","moved","_moved","closePopup","event","newPoint","_offset","subtract","eachLatLng","offset","resetBounds","_subtract","getPixelOrigin","oldPoint","_add","newLatLng","context","loop","isArray","getLatLng"],"mappings":"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","file":"Limapper.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"L\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Limapper\", [\"L\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Limapper\"] = factory(require(\"L\"));\n\telse\n\t\troot[\"Limapper\"] = factory(root[\"L\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_0__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","/*!\n *  Limapper.js - v0.2.2\n *  build: Wed May 10 2017 14:52:06 GMT-0500 (CDT)\n *  Leaflet Image Mapper\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"L\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Limapper\", [\"L\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Limapper\"] = factory(require(\"L\"));\n\telse\n\t\troot[\"Limapper\"] = factory(root[\"L\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_0__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 4);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _leaflet = __webpack_require__(0);\n\nvar _leaflet2 = _interopRequireDefault(_leaflet);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n__webpack_require__(3);\n__webpack_require__(2);\n\n/**\n * Leaflet Image Mapper\n */\n\nvar Limapper = function () {\n  /**\n   * initialize object\n   * @return {object} Instance\n   */\n  function Limapper() {\n    _classCallCheck(this, Limapper);\n\n    this._name = 'Limapper';\n  }\n\n  /**\n   * get name\n   * @return {string} name\n   */\n\n\n  _createClass(Limapper, [{\n    key: 'init',\n\n\n    /**\n     * initialize object\n     * @param  {object} opts options\n     * @return {object}      self\n     */\n    value: function init(opts) {\n      var self = this;\n      var defs = {\n        minZoom: 1,\n        maxZoom: 5,\n        center: [0, 0],\n        zoom: 1,\n        editable: true,\n        crs: _leaflet2.default.CRS.Simple\n      };\n      var southWest = void 0,\n          northEast = void 0,\n          bounds = void 0,\n          map = void 0;\n\n      // apply defaults\n      for (var k in defs) {\n        opts[k] = opts[k] || defs[k];\n      }\n      map = _leaflet2.default.map(opts.elid || 'map', opts);\n      southWest = map.unproject([0, opts.imageHeight]);\n      northEast = map.unproject([opts.imageWidth, 0]);\n      bounds = new _leaflet2.default.LatLngBounds(southWest, northEast);\n      _leaflet2.default.imageOverlay(opts.imageUrl, bounds).addTo(map);\n      map.setMaxBounds(bounds);\n      this._map = map;\n\n      _leaflet2.default.EditControl = _leaflet2.default.Control.extend({\n        options: {\n          position: 'topleft',\n          callback: null,\n          kind: '',\n          html: ''\n        },\n        onAdd: function onAdd(map) {\n          var container = _leaflet2.default.DomUtil.create('div', 'leaflet-control leaflet-bar'),\n              link = _leaflet2.default.DomUtil.create('a', '', container);\n\n          link.href = '#';\n          link.title = 'Create a new ' + this.options.kind;\n          link.innerHTML = this.options.html;\n          _leaflet2.default.DomEvent.on(link, 'click', _leaflet2.default.DomEvent.stop).on(link, 'click', function () {\n            window.LAYER = this.options.callback.call(map.editTools);\n          }, this);\n\n          return container;\n        }\n      });\n\n      map.on('layeradd', function (e) {\n        if (e.layer instanceof _leaflet2.default.Path) {\n          // self._items.push(e.layer);\n          setTimeout(function () {\n            self.items();\n          }, 100);\n        }\n      });\n\n      _leaflet2.default.NewRectangleControl = _leaflet2.default.EditControl.extend({\n        options: {\n          position: 'topleft',\n          callback: map.editTools.startRectangle,\n          kind: 'rect',\n          html: 'â¬›'\n        }\n      });\n\n      map.addControl(new _leaflet2.default.NewRectangleControl());\n\n      return self;\n    }\n  }, {\n    key: 'name',\n    get: function get() {\n      return this._name;\n    }\n\n    /**\n     * get items\n     * @return {Array} list of items\n     */\n\n  }, {\n    key: 'items',\n    get: function get() {\n      var self = this;\n\n      if (!self._map) {\n        return [];\n      }\n\n      var items = [];\n      var map = self._map;\n      var po = map.latLngToLayerPoint(new _leaflet2.default.LatLng(0, 0));\n\n      map.eachLayer(function (v, k) {\n        // handle rectangle\n        if (v.editor instanceof _leaflet2.default.Editable.RectangleEditor) {\n          if (v._bounds) {\n            if (!v.mydata) {\n              v.mydata = { rect: {} };\n            }\n            var nw = map.latLngToLayerPoint(v._bounds.getNorthWest());\n            var se = map.latLngToLayerPoint(v._bounds.getSouthEast());\n\n            v.mydata.rect.x1 = nw.x - po.x;\n            v.mydata.rect.x2 = se.x - po.x;\n            v.mydata.rect.y1 = nw.y - po.y;\n            v.mydata.rect.y2 = se.y - po.y;\n            items.push(v);\n          }\n        }\n      });\n\n      return items;\n    }\n  }]);\n\n  return Limapper;\n}();\n\nexports.default = Limapper;\nmodule.exports = exports['default'];\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n(function (factory, window) {\n    /*globals define, module, require*/\n\n    // define an AMD module that relies on 'leaflet'\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n    // define a Common JS module that relies on 'leaflet'\n    } else if (typeof exports === 'object') {\n        module.exports = factory(require('leaflet'));\n    }\n\n    // attach your plugin to the global 'L' variable\n    if(typeof window !== 'undefined' && window.L){\n        factory(window.L);\n    }\n\n}(function (L) {\n    // ðŸ‚miniclass CancelableEvent (Event objects)\n    // ðŸ‚method cancel()\n    // Cancel any subsequent action.\n\n    // ðŸ‚miniclass VertexEvent (Event objects)\n    // ðŸ‚property vertex: VertexMarker\n    // The vertex that fires the event.\n\n    // ðŸ‚miniclass ShapeEvent (Event objects)\n    // ðŸ‚property shape: Array\n    // The shape (LatLngs array) subject of the action.\n\n    // ðŸ‚miniclass CancelableVertexEvent (Event objects)\n    // ðŸ‚inherits VertexEvent\n    // ðŸ‚inherits CancelableEvent\n\n    // ðŸ‚miniclass CancelableShapeEvent (Event objects)\n    // ðŸ‚inherits ShapeEvent\n    // ðŸ‚inherits CancelableEvent\n\n    // ðŸ‚miniclass LayerEvent (Event objects)\n    // ðŸ‚property layer: object\n    // The Layer (Marker, Polylineâ€¦) subject of the action.\n\n    // ðŸ‚namespace Editable; ðŸ‚class Editable; ðŸ‚aka L.Editable\n    // Main edition handler. By default, it is attached to the map\n    // as `map.editTools` property.\n    // Leaflet.Editable is made to be fully extendable. You have three ways to customize\n    // the behaviour: using options, listening to events, or extending.\n    L.Editable = L.Evented.extend({\n\n        statics: {\n            FORWARD: 1,\n            BACKWARD: -1\n        },\n\n        options: {\n\n            // You can pass them when creating a map using the `editOptions` key.\n            // ðŸ‚option zIndex: int = 1000\n            // The default zIndex of the editing tools.\n            zIndex: 1000,\n\n            // ðŸ‚option polygonClass: class = L.Polygon\n            // Class to be used when creating a new Polygon.\n            polygonClass: L.Polygon,\n\n            // ðŸ‚option polylineClass: class = L.Polyline\n            // Class to be used when creating a new Polyline.\n            polylineClass: L.Polyline,\n\n            // ðŸ‚option markerClass: class = L.Marker\n            // Class to be used when creating a new Marker.\n            markerClass: L.Marker,\n\n            // ðŸ‚option rectangleClass: class = L.Rectangle\n            // Class to be used when creating a new Rectangle.\n            rectangleClass: L.Rectangle,\n\n            // ðŸ‚option circleClass: class = L.Circle\n            // Class to be used when creating a new Circle.\n            circleClass: L.Circle,\n\n            // ðŸ‚option drawingCSSClass: string = 'leaflet-editable-drawing'\n            // CSS class to be added to the map container while drawing.\n            drawingCSSClass: 'leaflet-editable-drawing',\n\n            // ðŸ‚option drawingCursor: const = 'crosshair'\n            // Cursor mode set to the map while drawing.\n            drawingCursor: 'crosshair',\n\n            // ðŸ‚option editLayer: Layer = new L.LayerGroup()\n            // Layer used to store edit tools (vertex, line guideâ€¦).\n            editLayer: undefined,\n\n            // ðŸ‚option featuresLayer: Layer = new L.LayerGroup()\n            // Default layer used to store drawn features (Marker, Polylineâ€¦).\n            featuresLayer: undefined,\n\n            // ðŸ‚option polylineEditorClass: class = PolylineEditor\n            // Class to be used as Polyline editor.\n            polylineEditorClass: undefined,\n\n            // ðŸ‚option polygonEditorClass: class = PolygonEditor\n            // Class to be used as Polygon editor.\n            polygonEditorClass: undefined,\n\n            // ðŸ‚option markerEditorClass: class = MarkerEditor\n            // Class to be used as Marker editor.\n            markerEditorClass: undefined,\n\n            // ðŸ‚option rectangleEditorClass: class = RectangleEditor\n            // Class to be used as Rectangle editor.\n            rectangleEditorClass: undefined,\n\n            // ðŸ‚option circleEditorClass: class = CircleEditor\n            // Class to be used as Circle editor.\n            circleEditorClass: undefined,\n\n            // ðŸ‚option lineGuideOptions: hash = {}\n            // Options to be passed to the line guides.\n            lineGuideOptions: {},\n\n            // ðŸ‚option skipMiddleMarkers: boolean = false\n            // Set this to true if you don't want middle markers.\n            skipMiddleMarkers: false\n\n        },\n\n        initialize: function (map, options) {\n            L.setOptions(this, options);\n            this._lastZIndex = this.options.zIndex;\n            this.map = map;\n            this.editLayer = this.createEditLayer();\n            this.featuresLayer = this.createFeaturesLayer();\n            this.forwardLineGuide = this.createLineGuide();\n            this.backwardLineGuide = this.createLineGuide();\n        },\n\n        fireAndForward: function (type, e) {\n            e = e || {};\n            e.editTools = this;\n            this.fire(type, e);\n            this.map.fire(type, e);\n        },\n\n        createLineGuide: function () {\n            var options = L.extend({dashArray: '5,10', weight: 1, interactive: false}, this.options.lineGuideOptions);\n            return L.polyline([], options);\n        },\n\n        createVertexIcon: function (options) {\n            return L.Browser.touch ? new L.Editable.TouchVertexIcon(options) : new L.Editable.VertexIcon(options);\n        },\n\n        createEditLayer: function () {\n            return this.options.editLayer || new L.LayerGroup().addTo(this.map);\n        },\n\n        createFeaturesLayer: function () {\n            return this.options.featuresLayer || new L.LayerGroup().addTo(this.map);\n        },\n\n        moveForwardLineGuide: function (latlng) {\n            if (this.forwardLineGuide._latlngs.length) {\n                this.forwardLineGuide._latlngs[1] = latlng;\n                this.forwardLineGuide._bounds.extend(latlng);\n                this.forwardLineGuide.redraw();\n            }\n        },\n\n        moveBackwardLineGuide: function (latlng) {\n            if (this.backwardLineGuide._latlngs.length) {\n                this.backwardLineGuide._latlngs[1] = latlng;\n                this.backwardLineGuide._bounds.extend(latlng);\n                this.backwardLineGuide.redraw();\n            }\n        },\n\n        anchorForwardLineGuide: function (latlng) {\n            this.forwardLineGuide._latlngs[0] = latlng;\n            this.forwardLineGuide._bounds.extend(latlng);\n            this.forwardLineGuide.redraw();\n        },\n\n        anchorBackwardLineGuide: function (latlng) {\n            this.backwardLineGuide._latlngs[0] = latlng;\n            this.backwardLineGuide._bounds.extend(latlng);\n            this.backwardLineGuide.redraw();\n        },\n\n        attachForwardLineGuide: function () {\n            this.editLayer.addLayer(this.forwardLineGuide);\n        },\n\n        attachBackwardLineGuide: function () {\n            this.editLayer.addLayer(this.backwardLineGuide);\n        },\n\n        detachForwardLineGuide: function () {\n            this.forwardLineGuide.setLatLngs([]);\n            this.editLayer.removeLayer(this.forwardLineGuide);\n        },\n\n        detachBackwardLineGuide: function () {\n            this.backwardLineGuide.setLatLngs([]);\n            this.editLayer.removeLayer(this.backwardLineGuide);\n        },\n\n        blockEvents: function () {\n            // Hack: force map not to listen to other layers events while drawing.\n            if (!this._oldTargets) {\n                this._oldTargets = this.map._targets;\n                this.map._targets = {};\n            }\n        },\n\n        unblockEvents: function () {\n            if (this._oldTargets) {\n                // Reset, but keep targets created while drawing.\n                this.map._targets = L.extend(this.map._targets, this._oldTargets);\n                delete this._oldTargets;\n            }\n        },\n\n        registerForDrawing: function (editor) {\n            if (this._drawingEditor) this.unregisterForDrawing(this._drawingEditor);\n            this.blockEvents();\n            editor.reset();  // Make sure editor tools still receive events.\n            this._drawingEditor = editor;\n            this.map.on('mousemove touchmove', editor.onDrawingMouseMove, editor);\n            this.map.on('mousedown', this.onMousedown, this);\n            this.map.on('mouseup', this.onMouseup, this);\n            L.DomUtil.addClass(this.map._container, this.options.drawingCSSClass);\n            this.defaultMapCursor = this.map._container.style.cursor;\n            this.map._container.style.cursor = this.options.drawingCursor;\n        },\n\n        unregisterForDrawing: function (editor) {\n            this.unblockEvents();\n            L.DomUtil.removeClass(this.map._container, this.options.drawingCSSClass);\n            this.map._container.style.cursor = this.defaultMapCursor;\n            editor = editor || this._drawingEditor;\n            if (!editor) return;\n            this.map.off('mousemove touchmove', editor.onDrawingMouseMove, editor);\n            this.map.off('mousedown', this.onMousedown, this);\n            this.map.off('mouseup', this.onMouseup, this);\n            if (editor !== this._drawingEditor) return;\n            delete this._drawingEditor;\n            if (editor._drawing) editor.cancelDrawing();\n        },\n\n        onMousedown: function (e) {\n            this._mouseDown = e;\n            this._drawingEditor.onDrawingMouseDown(e);\n        },\n\n        onMouseup: function (e) {\n            if (this._mouseDown) {\n                var editor = this._drawingEditor,\n                    mouseDown = this._mouseDown;\n                this._mouseDown = null;\n                editor.onDrawingMouseUp(e);\n                if (this._drawingEditor !== editor) return;  // onDrawingMouseUp may call unregisterFromDrawing.\n                var origin = L.point(mouseDown.originalEvent.clientX, mouseDown.originalEvent.clientY);\n                var distance = L.point(e.originalEvent.clientX, e.originalEvent.clientY).distanceTo(origin);\n                if (Math.abs(distance) < 9 * (window.devicePixelRatio || 1)) this._drawingEditor.onDrawingClick(e);\n            }\n        },\n\n        // ðŸ‚section Public methods\n        // You will generally access them by the `map.editTools`\n        // instance:\n        //\n        // `map.editTools.startPolyline();`\n\n        // ðŸ‚method drawing(): boolean\n        // Return true if any drawing action is ongoing.\n        drawing: function () {\n            return this._drawingEditor && this._drawingEditor.drawing();\n        },\n\n        // ðŸ‚method stopDrawing()\n        // When you need to stop any ongoing drawing, without needing to know which editor is active.\n        stopDrawing: function () {\n            this.unregisterForDrawing();\n        },\n\n        // ðŸ‚method commitDrawing()\n        // When you need to commit any ongoing drawing, without needing to know which editor is active.\n        commitDrawing: function (e) {\n            if (!this._drawingEditor) return;\n            this._drawingEditor.commitDrawing(e);\n        },\n\n        connectCreatedToMap: function (layer) {\n            return this.featuresLayer.addLayer(layer);\n        },\n\n        // ðŸ‚method startPolyline(latlng: L.LatLng, options: hash): L.Polyline\n        // Start drawing a Polyline. If `latlng` is given, a first point will be added. In any case, continuing on user click.\n        // If `options` is given, it will be passed to the Polyline class constructor.\n        startPolyline: function (latlng, options) {\n            var line = this.createPolyline([], options);\n            line.enableEdit(this.map).newShape(latlng);\n            return line;\n        },\n\n        // ðŸ‚method startPolygon(latlng: L.LatLng, options: hash): L.Polygon\n        // Start drawing a Polygon. If `latlng` is given, a first point will be added. In any case, continuing on user click.\n        // If `options` is given, it will be passed to the Polygon class constructor.\n        startPolygon: function (latlng, options) {\n            var polygon = this.createPolygon([], options);\n            polygon.enableEdit(this.map).newShape(latlng);\n            return polygon;\n        },\n\n        // ðŸ‚method startMarker(latlng: L.LatLng, options: hash): L.Marker\n        // Start adding a Marker. If `latlng` is given, the Marker will be shown first at this point.\n        // In any case, it will follow the user mouse, and will have a final `latlng` on next click (or touch).\n        // If `options` is given, it will be passed to the Marker class constructor.\n        startMarker: function (latlng, options) {\n            latlng = latlng || this.map.getCenter().clone();\n            var marker = this.createMarker(latlng, options);\n            marker.enableEdit(this.map).startDrawing();\n            return marker;\n        },\n\n        // ðŸ‚method startRectangle(latlng: L.LatLng, options: hash): L.Rectangle\n        // Start drawing a Rectangle. If `latlng` is given, the Rectangle anchor will be added. In any case, continuing on user drag.\n        // If `options` is given, it will be passed to the Rectangle class constructor.\n        startRectangle: function(latlng, options) {\n            var corner = latlng || L.latLng([0, 0]);\n            var bounds = new L.LatLngBounds(corner, corner);\n            var rectangle = this.createRectangle(bounds, options);\n            rectangle.enableEdit(this.map).startDrawing();\n            return rectangle;\n        },\n\n        // ðŸ‚method startCircle(latlng: L.LatLng, options: hash): L.Circle\n        // Start drawing a Circle. If `latlng` is given, the Circle anchor will be added. In any case, continuing on user drag.\n        // If `options` is given, it will be passed to the Circle class constructor.\n        startCircle: function (latlng, options) {\n            latlng = latlng || this.map.getCenter().clone();\n            var circle = this.createCircle(latlng, options);\n            circle.enableEdit(this.map).startDrawing();\n            return circle;\n        },\n\n        startHole: function (editor, latlng) {\n            editor.newHole(latlng);\n        },\n\n        createLayer: function (klass, latlngs, options) {\n            options = L.Util.extend({editOptions: {editTools: this}}, options);\n            var layer = new klass(latlngs, options);\n            // ðŸ‚namespace Editable\n            // ðŸ‚event editable:created: LayerEvent\n            // Fired when a new feature (Marker, Polylineâ€¦) is created.\n            this.fireAndForward('editable:created', {layer: layer});\n            return layer;\n        },\n\n        createPolyline: function (latlngs, options) {\n            return this.createLayer(options && options.polylineClass || this.options.polylineClass, latlngs, options);\n        },\n\n        createPolygon: function (latlngs, options) {\n            return this.createLayer(options && options.polygonClass || this.options.polygonClass, latlngs, options);\n        },\n\n        createMarker: function (latlng, options) {\n            return this.createLayer(options && options.markerClass || this.options.markerClass, latlng, options);\n        },\n\n        createRectangle: function (bounds, options) {\n            return this.createLayer(options && options.rectangleClass || this.options.rectangleClass, bounds, options);\n        },\n\n        createCircle: function (latlng, options) {\n            return this.createLayer(options && options.circleClass || this.options.circleClass, latlng, options);\n        }\n\n    });\n\n    L.extend(L.Editable, {\n\n        makeCancellable: function (e) {\n            e.cancel = function () {\n                e._cancelled = true;\n            };\n        }\n\n    });\n\n    // ðŸ‚namespace Map; ðŸ‚class Map\n    // Leaflet.Editable add options and events to the `L.Map` object.\n    // See `Editable` events for the list of events fired on the Map.\n    // ðŸ‚example\n    //\n    // ```js\n    // var map = L.map('map', {\n    //  editable: true,\n    //  editOptions: {\n    //    â€¦\n    // }\n    // });\n    // ```\n    // ðŸ‚section Editable Map Options\n    L.Map.mergeOptions({\n\n        // ðŸ‚namespace Map\n        // ðŸ‚section Map Options\n        // ðŸ‚option editToolsClass: class = L.Editable\n        // Class to be used as vertex, for path editing.\n        editToolsClass: L.Editable,\n\n        // ðŸ‚option editable: boolean = false\n        // Whether to create a L.Editable instance at map init.\n        editable: false,\n\n        // ðŸ‚option editOptions: hash = {}\n        // Options to pass to L.Editable when instanciating.\n        editOptions: {}\n\n    });\n\n    L.Map.addInitHook(function () {\n\n        this.whenReady(function () {\n            if (this.options.editable) {\n                this.editTools = new this.options.editToolsClass(this, this.options.editOptions);\n            }\n        });\n\n    });\n\n    L.Editable.VertexIcon = L.DivIcon.extend({\n\n        options: {\n            iconSize: new L.Point(8, 8)\n        }\n\n    });\n\n    L.Editable.TouchVertexIcon = L.Editable.VertexIcon.extend({\n\n        options: {\n            iconSize: new L.Point(20, 20)\n        }\n\n    });\n\n\n    // ðŸ‚namespace Editable; ðŸ‚class VertexMarker; Handler for dragging path vertices.\n    L.Editable.VertexMarker = L.Marker.extend({\n\n        options: {\n            draggable: true,\n            className: 'leaflet-div-icon leaflet-vertex-icon'\n        },\n\n\n        // ðŸ‚section Public methods\n        // The marker used to handle path vertex. You will usually interact with a `VertexMarker`\n        // instance when listening for events like `editable:vertex:ctrlclick`.\n\n        initialize: function (latlng, latlngs, editor, options) {\n            // We don't use this._latlng, because on drag Leaflet replace it while\n            // we want to keep reference.\n            this.latlng = latlng;\n            this.latlngs = latlngs;\n            this.editor = editor;\n            L.Marker.prototype.initialize.call(this, latlng, options);\n            this.options.icon = this.editor.tools.createVertexIcon({className: this.options.className});\n            this.latlng.__vertex = this;\n            this.editor.editLayer.addLayer(this);\n            this.setZIndexOffset(editor.tools._lastZIndex + 1);\n        },\n\n        onAdd: function (map) {\n            L.Marker.prototype.onAdd.call(this, map);\n            this.on('drag', this.onDrag);\n            this.on('dragstart', this.onDragStart);\n            this.on('dragend', this.onDragEnd);\n            this.on('mouseup', this.onMouseup);\n            this.on('click', this.onClick);\n            this.on('contextmenu', this.onContextMenu);\n            this.on('mousedown touchstart', this.onMouseDown);\n            this.addMiddleMarkers();\n        },\n\n        onRemove: function (map) {\n            if (this.middleMarker) this.middleMarker.delete();\n            delete this.latlng.__vertex;\n            this.off('drag', this.onDrag);\n            this.off('dragstart', this.onDragStart);\n            this.off('dragend', this.onDragEnd);\n            this.off('mouseup', this.onMouseup);\n            this.off('click', this.onClick);\n            this.off('contextmenu', this.onContextMenu);\n            this.off('mousedown touchstart', this.onMouseDown);\n            L.Marker.prototype.onRemove.call(this, map);\n        },\n\n        onDrag: function (e) {\n            e.vertex = this;\n            this.editor.onVertexMarkerDrag(e);\n            var iconPos = L.DomUtil.getPosition(this._icon),\n                latlng = this._map.layerPointToLatLng(iconPos);\n            this.latlng.update(latlng);\n            this._latlng = this.latlng;  // Push back to Leaflet our reference.\n            this.editor.refresh();\n            if (this.middleMarker) this.middleMarker.updateLatLng();\n            var next = this.getNext();\n            if (next && next.middleMarker) next.middleMarker.updateLatLng();\n        },\n\n        onDragStart: function (e) {\n            e.vertex = this;\n            this.editor.onVertexMarkerDragStart(e);\n        },\n\n        onDragEnd: function (e) {\n            e.vertex = this;\n            this.editor.onVertexMarkerDragEnd(e);\n        },\n\n        onClick: function (e) {\n            e.vertex = this;\n            this.editor.onVertexMarkerClick(e);\n        },\n\n        onMouseup: function (e) {\n            L.DomEvent.stop(e);\n            e.vertex = this;\n            this.editor.map.fire('mouseup', e);\n        },\n\n        onContextMenu: function (e) {\n            e.vertex = this;\n            this.editor.onVertexMarkerContextMenu(e);\n        },\n\n        onMouseDown: function (e) {\n            e.vertex = this;\n            this.editor.onVertexMarkerMouseDown(e);\n        },\n\n        // ðŸ‚method delete()\n        // Delete a vertex and the related LatLng.\n        delete: function () {\n            var next = this.getNext();  // Compute before changing latlng\n            this.latlngs.splice(this.getIndex(), 1);\n            this.editor.editLayer.removeLayer(this);\n            this.editor.onVertexDeleted({latlng: this.latlng, vertex: this});\n            if (!this.latlngs.length) this.editor.deleteShape(this.latlngs);\n            if (next) next.resetMiddleMarker();\n            this.editor.refresh();\n        },\n\n        // ðŸ‚method getIndex(): int\n        // Get the index of the current vertex among others of the same LatLngs group.\n        getIndex: function () {\n            return this.latlngs.indexOf(this.latlng);\n        },\n\n        // ðŸ‚method getLastIndex(): int\n        // Get last vertex index of the LatLngs group of the current vertex.\n        getLastIndex: function () {\n            return this.latlngs.length - 1;\n        },\n\n        // ðŸ‚method getPrevious(): VertexMarker\n        // Get the previous VertexMarker in the same LatLngs group.\n        getPrevious: function () {\n            if (this.latlngs.length < 2) return;\n            var index = this.getIndex(),\n                previousIndex = index - 1;\n            if (index === 0 && this.editor.CLOSED) previousIndex = this.getLastIndex();\n            var previous = this.latlngs[previousIndex];\n            if (previous) return previous.__vertex;\n        },\n\n        // ðŸ‚method getNext(): VertexMarker\n        // Get the next VertexMarker in the same LatLngs group.\n        getNext: function () {\n            if (this.latlngs.length < 2) return;\n            var index = this.getIndex(),\n                nextIndex = index + 1;\n            if (index === this.getLastIndex() && this.editor.CLOSED) nextIndex = 0;\n            var next = this.latlngs[nextIndex];\n            if (next) return next.__vertex;\n        },\n\n        addMiddleMarker: function (previous) {\n            if (!this.editor.hasMiddleMarkers()) return;\n            previous = previous || this.getPrevious();\n            if (previous && !this.middleMarker) this.middleMarker = this.editor.addMiddleMarker(previous, this, this.latlngs, this.editor);\n        },\n\n        addMiddleMarkers: function () {\n            if (!this.editor.hasMiddleMarkers()) return;\n            var previous = this.getPrevious();\n            if (previous) this.addMiddleMarker(previous);\n            var next = this.getNext();\n            if (next) next.resetMiddleMarker();\n        },\n\n        resetMiddleMarker: function () {\n            if (this.middleMarker) this.middleMarker.delete();\n            this.addMiddleMarker();\n        },\n\n        // ðŸ‚method split()\n        // Split the vertex LatLngs group at its index, if possible.\n        split: function () {\n            if (!this.editor.splitShape) return;  // Only for PolylineEditor\n            this.editor.splitShape(this.latlngs, this.getIndex());\n        },\n\n        // ðŸ‚method continue()\n        // Continue the vertex LatLngs from this vertex. Only active for first and last vertices of a Polyline.\n        continue: function () {\n            if (!this.editor.continueBackward) return;  // Only for PolylineEditor\n            var index = this.getIndex();\n            if (index === 0) this.editor.continueBackward(this.latlngs);\n            else if (index === this.getLastIndex()) this.editor.continueForward(this.latlngs);\n        }\n\n    });\n\n    L.Editable.mergeOptions({\n\n        // ðŸ‚namespace Editable\n        // ðŸ‚option vertexMarkerClass: class = VertexMarker\n        // Class to be used as vertex, for path editing.\n        vertexMarkerClass: L.Editable.VertexMarker\n\n    });\n\n    L.Editable.MiddleMarker = L.Marker.extend({\n\n        options: {\n            opacity: 0.5,\n            className: 'leaflet-div-icon leaflet-middle-icon',\n            draggable: true\n        },\n\n        initialize: function (left, right, latlngs, editor, options) {\n            this.left = left;\n            this.right = right;\n            this.editor = editor;\n            this.latlngs = latlngs;\n            L.Marker.prototype.initialize.call(this, this.computeLatLng(), options);\n            this._opacity = this.options.opacity;\n            this.options.icon = this.editor.tools.createVertexIcon({className: this.options.className});\n            this.editor.editLayer.addLayer(this);\n            this.setVisibility();\n        },\n\n        setVisibility: function () {\n            var leftPoint = this._map.latLngToContainerPoint(this.left.latlng),\n                rightPoint = this._map.latLngToContainerPoint(this.right.latlng),\n                size = L.point(this.options.icon.options.iconSize);\n            if (leftPoint.distanceTo(rightPoint) < size.x * 3) this.hide();\n            else this.show();\n        },\n\n        show: function () {\n            this.setOpacity(this._opacity);\n        },\n\n        hide: function () {\n            this.setOpacity(0);\n        },\n\n        updateLatLng: function () {\n            this.setLatLng(this.computeLatLng());\n            this.setVisibility();\n        },\n\n        computeLatLng: function () {\n            var leftPoint = this.editor.map.latLngToContainerPoint(this.left.latlng),\n                rightPoint = this.editor.map.latLngToContainerPoint(this.right.latlng),\n                y = (leftPoint.y + rightPoint.y) / 2,\n                x = (leftPoint.x + rightPoint.x) / 2;\n            return this.editor.map.containerPointToLatLng([x, y]);\n        },\n\n        onAdd: function (map) {\n            L.Marker.prototype.onAdd.call(this, map);\n            L.DomEvent.on(this._icon, 'mousedown touchstart', this.onMouseDown, this);\n            map.on('zoomend', this.setVisibility, this);\n        },\n\n        onRemove: function (map) {\n            delete this.right.middleMarker;\n            L.DomEvent.off(this._icon, 'mousedown touchstart', this.onMouseDown, this);\n            map.off('zoomend', this.setVisibility, this);\n            L.Marker.prototype.onRemove.call(this, map);\n        },\n\n        onMouseDown: function (e) {\n            var iconPos = L.DomUtil.getPosition(this._icon),\n                latlng = this.editor.map.layerPointToLatLng(iconPos);\n            e = {\n                originalEvent: e,\n                latlng: latlng\n            };\n            if (this.options.opacity === 0) return;\n            L.Editable.makeCancellable(e);\n            this.editor.onMiddleMarkerMouseDown(e);\n            if (e._cancelled) return;\n            this.latlngs.splice(this.index(), 0, e.latlng);\n            this.editor.refresh();\n            var icon = this._icon;\n            var marker = this.editor.addVertexMarker(e.latlng, this.latlngs);\n            /* Hack to workaround browser not firing touchend when element is no more on DOM */\n            var parent = marker._icon.parentNode;\n            parent.removeChild(marker._icon);\n            marker._icon = icon;\n            parent.appendChild(marker._icon);\n            marker._initIcon();\n            marker._initInteraction();\n            marker.setOpacity(1);\n            /* End hack */\n            // Transfer ongoing dragging to real marker\n            L.Draggable._dragging = false;\n            marker.dragging._draggable._onDown(e.originalEvent);\n            this.delete();\n        },\n\n        delete: function () {\n            this.editor.editLayer.removeLayer(this);\n        },\n\n        index: function () {\n            return this.latlngs.indexOf(this.right.latlng);\n        }\n\n    });\n\n    L.Editable.mergeOptions({\n\n        // ðŸ‚namespace Editable\n        // ðŸ‚option middleMarkerClass: class = VertexMarker\n        // Class to be used as middle vertex, pulled by the user to create a new point in the middle of a path.\n        middleMarkerClass: L.Editable.MiddleMarker\n\n    });\n\n    // ðŸ‚namespace Editable; ðŸ‚class BaseEditor; ðŸ‚aka L.Editable.BaseEditor\n    // When editing a feature (Marker, Polylineâ€¦), an editor is attached to it. This\n    // editor basically knows how to handle the edition.\n    L.Editable.BaseEditor = L.Handler.extend({\n\n        initialize: function (map, feature, options) {\n            L.setOptions(this, options);\n            this.map = map;\n            this.feature = feature;\n            this.feature.editor = this;\n            this.editLayer = new L.LayerGroup();\n            this.tools = this.options.editTools || map.editTools;\n        },\n\n        // ðŸ‚method enable(): this\n        // Set up the drawing tools for the feature to be editable.\n        addHooks: function () {\n            if (this.isConnected()) this.onFeatureAdd();\n            else this.feature.once('add', this.onFeatureAdd, this);\n            this.onEnable();\n            this.feature.on(this._getEvents(), this);\n            return;\n        },\n\n        // ðŸ‚method disable(): this\n        // Remove the drawing tools for the feature.\n        removeHooks: function () {\n            this.feature.off(this._getEvents(), this);\n            if (this.feature.dragging) this.feature.dragging.disable();\n            this.editLayer.clearLayers();\n            this.tools.editLayer.removeLayer(this.editLayer);\n            this.onDisable();\n            if (this._drawing) this.cancelDrawing();\n            return;\n        },\n\n        // ðŸ‚method drawing(): boolean\n        // Return true if any drawing action is ongoing with this editor.\n        drawing: function () {\n            return !!this._drawing;\n        },\n\n        reset: function () {},\n\n        onFeatureAdd: function () {\n            this.tools.editLayer.addLayer(this.editLayer);\n            if (this.feature.dragging) this.feature.dragging.enable();\n        },\n\n        hasMiddleMarkers: function () {\n            return !this.options.skipMiddleMarkers && !this.tools.options.skipMiddleMarkers;\n        },\n\n        fireAndForward: function (type, e) {\n            e = e || {};\n            e.layer = this.feature;\n            this.feature.fire(type, e);\n            this.tools.fireAndForward(type, e);\n        },\n\n        onEnable: function () {\n            // ðŸ‚namespace Editable\n            // ðŸ‚event editable:enable: Event\n            // Fired when an existing feature is ready to be edited.\n            this.fireAndForward('editable:enable');\n        },\n\n        onDisable: function () {\n            // ðŸ‚namespace Editable\n            // ðŸ‚event editable:disable: Event\n            // Fired when an existing feature is not ready anymore to be edited.\n            this.fireAndForward('editable:disable');\n        },\n\n        onEditing: function () {\n            // ðŸ‚namespace Editable\n            // ðŸ‚event editable:editing: Event\n            // Fired as soon as any change is made to the feature geometry.\n            this.fireAndForward('editable:editing');\n        },\n\n        onStartDrawing: function () {\n            // ðŸ‚namespace Editable\n            // ðŸ‚section Drawing events\n            // ðŸ‚event editable:drawing:start: Event\n            // Fired when a feature is to be drawn.\n            this.fireAndForward('editable:drawing:start');\n        },\n\n        onEndDrawing: function () {\n            // ðŸ‚namespace Editable\n            // ðŸ‚section Drawing events\n            // ðŸ‚event editable:drawing:end: Event\n            // Fired when a feature is not drawn anymore.\n            this.fireAndForward('editable:drawing:end');\n        },\n\n        onCancelDrawing: function () {\n            // ðŸ‚namespace Editable\n            // ðŸ‚section Drawing events\n            // ðŸ‚event editable:drawing:cancel: Event\n            // Fired when user cancel drawing while a feature is being drawn.\n            this.fireAndForward('editable:drawing:cancel');\n        },\n\n        onCommitDrawing: function (e) {\n            // ðŸ‚namespace Editable\n            // ðŸ‚section Drawing events\n            // ðŸ‚event editable:drawing:commit: Event\n            // Fired when user finish drawing a feature.\n            this.fireAndForward('editable:drawing:commit', e);\n        },\n\n        onDrawingMouseDown: function (e) {\n            // ðŸ‚namespace Editable\n            // ðŸ‚section Drawing events\n            // ðŸ‚event editable:drawing:mousedown: Event\n            // Fired when user `mousedown` while drawing.\n            this.fireAndForward('editable:drawing:mousedown', e);\n        },\n\n        onDrawingMouseUp: function (e) {\n            // ðŸ‚namespace Editable\n            // ðŸ‚section Drawing events\n            // ðŸ‚event editable:drawing:mouseup: Event\n            // Fired when user `mouseup` while drawing.\n            this.fireAndForward('editable:drawing:mouseup', e);\n        },\n\n        startDrawing: function () {\n            if (!this._drawing) this._drawing = L.Editable.FORWARD;\n            this.tools.registerForDrawing(this);\n            this.onStartDrawing();\n        },\n\n        commitDrawing: function (e) {\n            this.onCommitDrawing(e);\n            this.endDrawing();\n        },\n\n        cancelDrawing: function () {\n            // If called during a vertex drag, the vertex will be removed before\n            // the mouseup fires on it. This is a workaround. Maybe better fix is\n            // To have L.Draggable reset it's status on disable (Leaflet side).\n            L.Draggable._dragging = false;\n            this.onCancelDrawing();\n            this.endDrawing();\n        },\n\n        endDrawing: function () {\n            this._drawing = false;\n            this.tools.unregisterForDrawing(this);\n            this.onEndDrawing();\n        },\n\n        onDrawingClick: function (e) {\n            if (!this.drawing()) return;\n            L.Editable.makeCancellable(e);\n            // ðŸ‚namespace Editable\n            // ðŸ‚section Drawing events\n            // ðŸ‚event editable:drawing:click: CancelableEvent\n            // Fired when user `click` while drawing, before any internal action is being processed.\n            this.fireAndForward('editable:drawing:click', e);\n            if (e._cancelled) return;\n            if (!this.isConnected()) this.connect(e);\n            this.processDrawingClick(e);\n        },\n\n        isConnected: function () {\n            return this.map.hasLayer(this.feature);\n        },\n\n        connect: function (e) {\n            this.tools.connectCreatedToMap(this.feature);\n            this.tools.editLayer.addLayer(this.editLayer);\n        },\n\n        onMove: function (e) {\n            // ðŸ‚namespace Editable\n            // ðŸ‚section Drawing events\n            // ðŸ‚event editable:drawing:move: Event\n            // Fired when `move` mouse while drawing, while dragging a marker, and while dragging a vertex.\n            this.fireAndForward('editable:drawing:move', e);\n        },\n\n        onDrawingMouseMove: function (e) {\n            this.onMove(e);\n        },\n\n        _getEvents: function () {\n            return {\n                dragstart: this.onDragStart,\n                drag: this.onDrag,\n                dragend: this.onDragEnd,\n                remove: this.disable\n            };\n        },\n\n        onDragStart: function (e) {\n            this.onEditing();\n            // ðŸ‚namespace Editable\n            // ðŸ‚event editable:dragstart: Event\n            // Fired before a path feature is dragged.\n            this.fireAndForward('editable:dragstart', e);\n        },\n\n        onDrag: function (e) {\n            this.onMove(e);\n            // ðŸ‚namespace Editable\n            // ðŸ‚event editable:drag: Event\n            // Fired when a path feature is being dragged.\n            this.fireAndForward('editable:drag', e);\n        },\n\n        onDragEnd: function (e) {\n            // ðŸ‚namespace Editable\n            // ðŸ‚event editable:dragend: Event\n            // Fired after a path feature has been dragged.\n            this.fireAndForward('editable:dragend', e);\n        }\n\n    });\n\n    // ðŸ‚namespace Editable; ðŸ‚class MarkerEditor; ðŸ‚aka L.Editable.MarkerEditor\n    // ðŸ‚inherits BaseEditor\n    // Editor for Marker.\n    L.Editable.MarkerEditor = L.Editable.BaseEditor.extend({\n\n        onDrawingMouseMove: function (e) {\n            L.Editable.BaseEditor.prototype.onDrawingMouseMove.call(this, e);\n            if (this._drawing) this.feature.setLatLng(e.latlng);\n        },\n\n        processDrawingClick: function (e) {\n            // ðŸ‚namespace Editable\n            // ðŸ‚section Drawing events\n            // ðŸ‚event editable:drawing:clicked: Event\n            // Fired when user `click` while drawing, after all internal actions.\n            this.fireAndForward('editable:drawing:clicked', e);\n            this.commitDrawing(e);\n        },\n\n        connect: function (e) {\n            // On touch, the latlng has not been updated because there is\n            // no mousemove.\n            if (e) this.feature._latlng = e.latlng;\n            L.Editable.BaseEditor.prototype.connect.call(this, e);\n        }\n\n    });\n\n    // ðŸ‚namespace Editable; ðŸ‚class PathEditor; ðŸ‚aka L.Editable.PathEditor\n    // ðŸ‚inherits BaseEditor\n    // Base class for all path editors.\n    L.Editable.PathEditor = L.Editable.BaseEditor.extend({\n\n        CLOSED: false,\n        MIN_VERTEX: 2,\n\n        addHooks: function () {\n            L.Editable.BaseEditor.prototype.addHooks.call(this);\n            if (this.feature) this.initVertexMarkers();\n            return this;\n        },\n\n        initVertexMarkers: function (latlngs) {\n            if (!this.enabled()) return;\n            latlngs = latlngs || this.getLatLngs();\n            if (L.Polyline._flat(latlngs)) this.addVertexMarkers(latlngs);\n            else for (var i = 0; i < latlngs.length; i++) this.initVertexMarkers(latlngs[i]);\n        },\n\n        getLatLngs: function () {\n            return this.feature.getLatLngs();\n        },\n\n        // ðŸ‚method reset()\n        // Rebuild edit elements (Vertex, MiddleMarker, etc.).\n        reset: function () {\n            this.editLayer.clearLayers();\n            this.initVertexMarkers();\n        },\n\n        addVertexMarker: function (latlng, latlngs) {\n            return new this.tools.options.vertexMarkerClass(latlng, latlngs, this);\n        },\n\n        addVertexMarkers: function (latlngs) {\n            for (var i = 0; i < latlngs.length; i++) {\n                this.addVertexMarker(latlngs[i], latlngs);\n            }\n        },\n\n        refreshVertexMarkers: function (latlngs) {\n            latlngs = latlngs || this.getDefaultLatLngs();\n            for (var i = 0; i < latlngs.length; i++) {\n                latlngs[i].__vertex.update();\n            }\n        },\n\n        addMiddleMarker: function (left, right, latlngs) {\n            return new this.tools.options.middleMarkerClass(left, right, latlngs, this);\n        },\n\n        onVertexMarkerClick: function (e) {\n            L.Editable.makeCancellable(e);\n            // ðŸ‚namespace Editable\n            // ðŸ‚section Vertex events\n            // ðŸ‚event editable:vertex:click: CancelableVertexEvent\n            // Fired when a `click` is issued on a vertex, before any internal action is being processed.\n            this.fireAndForward('editable:vertex:click', e);\n            if (e._cancelled) return;\n            if (this.tools.drawing() && this.tools._drawingEditor !== this) return;\n            var index = e.vertex.getIndex(), commit;\n            if (e.originalEvent.ctrlKey) {\n                this.onVertexMarkerCtrlClick(e);\n            } else if (e.originalEvent.altKey) {\n                this.onVertexMarkerAltClick(e);\n            } else if (e.originalEvent.shiftKey) {\n                this.onVertexMarkerShiftClick(e);\n            } else if (e.originalEvent.metaKey) {\n                this.onVertexMarkerMetaKeyClick(e);\n            } else if (index === e.vertex.getLastIndex() && this._drawing === L.Editable.FORWARD) {\n                if (index >= this.MIN_VERTEX - 1) commit = true;\n            } else if (index === 0 && this._drawing === L.Editable.BACKWARD && this._drawnLatLngs.length >= this.MIN_VERTEX) {\n                commit = true;\n            } else if (index === 0 && this._drawing === L.Editable.FORWARD && this._drawnLatLngs.length >= this.MIN_VERTEX && this.CLOSED) {\n                commit = true;  // Allow to close on first point also for polygons\n            } else {\n                this.onVertexRawMarkerClick(e);\n            }\n            // ðŸ‚namespace Editable\n            // ðŸ‚section Vertex events\n            // ðŸ‚event editable:vertex:clicked: VertexEvent\n            // Fired when a `click` is issued on a vertex, after all internal actions.\n            this.fireAndForward('editable:vertex:clicked', e);\n            if (commit) this.commitDrawing(e);\n        },\n\n        onVertexRawMarkerClick: function (e) {\n            // ðŸ‚namespace Editable\n            // ðŸ‚section Vertex events\n            // ðŸ‚event editable:vertex:rawclick: CancelableVertexEvent\n            // Fired when a `click` is issued on a vertex without any special key and without being in drawing mode.\n            this.fireAndForward('editable:vertex:rawclick', e);\n            if (e._cancelled) return;\n            if (!this.vertexCanBeDeleted(e.vertex)) return;\n            e.vertex.delete();\n        },\n\n        vertexCanBeDeleted: function (vertex) {\n            return vertex.latlngs.length > this.MIN_VERTEX;\n        },\n\n        onVertexDeleted: function (e) {\n            // ðŸ‚namespace Editable\n            // ðŸ‚section Vertex events\n            // ðŸ‚event editable:vertex:deleted: VertexEvent\n            // Fired after a vertex has been deleted by user.\n            this.fireAndForward('editable:vertex:deleted', e);\n        },\n\n        onVertexMarkerCtrlClick: function (e) {\n            // ðŸ‚namespace Editable\n            // ðŸ‚section Vertex events\n            // ðŸ‚event editable:vertex:ctrlclick: VertexEvent\n            // Fired when a `click` with `ctrlKey` is issued on a vertex.\n            this.fireAndForward('editable:vertex:ctrlclick', e);\n        },\n\n        onVertexMarkerShiftClick: function (e) {\n            // ðŸ‚namespace Editable\n            // ðŸ‚section Vertex events\n            // ðŸ‚event editable:vertex:shiftclick: VertexEvent\n            // Fired when a `click` with `shiftKey` is issued on a vertex.\n            this.fireAndForward('editable:vertex:shiftclick', e);\n        },\n\n        onVertexMarkerMetaKeyClick: function (e) {\n            // ðŸ‚namespace Editable\n            // ðŸ‚section Vertex events\n            // ðŸ‚event editable:vertex:metakeyclick: VertexEvent\n            // Fired when a `click` with `metaKey` is issued on a vertex.\n            this.fireAndForward('editable:vertex:metakeyclick', e);\n        },\n\n        onVertexMarkerAltClick: function (e) {\n            // ðŸ‚namespace Editable\n            // ðŸ‚section Vertex events\n            // ðŸ‚event editable:vertex:altclick: VertexEvent\n            // Fired when a `click` with `altKey` is issued on a vertex.\n            this.fireAndForward('editable:vertex:altclick', e);\n        },\n\n        onVertexMarkerContextMenu: function (e) {\n            // ðŸ‚namespace Editable\n            // ðŸ‚section Vertex events\n            // ðŸ‚event editable:vertex:contextmenu: VertexEvent\n            // Fired when a `contextmenu` is issued on a vertex.\n            this.fireAndForward('editable:vertex:contextmenu', e);\n        },\n\n        onVertexMarkerMouseDown: function (e) {\n            // ðŸ‚namespace Editable\n            // ðŸ‚section Vertex events\n            // ðŸ‚event editable:vertex:mousedown: VertexEvent\n            // Fired when user `mousedown` a vertex.\n            this.fireAndForward('editable:vertex:mousedown', e);\n        },\n\n        onMiddleMarkerMouseDown: function (e) {\n            // ðŸ‚namespace Editable\n            // ðŸ‚section MiddleMarker events\n            // ðŸ‚event editable:middlemarker:mousedown: VertexEvent\n            // Fired when user `mousedown` a middle marker.\n            this.fireAndForward('editable:middlemarker:mousedown', e);\n        },\n\n        onVertexMarkerDrag: function (e) {\n            this.onMove(e);\n            if (this.feature._bounds) this.extendBounds(e);\n            // ðŸ‚namespace Editable\n            // ðŸ‚section Vertex events\n            // ðŸ‚event editable:vertex:drag: VertexEvent\n            // Fired when a vertex is dragged by user.\n            this.fireAndForward('editable:vertex:drag', e);\n        },\n\n        onVertexMarkerDragStart: function (e) {\n            // ðŸ‚namespace Editable\n            // ðŸ‚section Vertex events\n            // ðŸ‚event editable:vertex:dragstart: VertexEvent\n            // Fired before a vertex is dragged by user.\n            this.fireAndForward('editable:vertex:dragstart', e);\n        },\n\n        onVertexMarkerDragEnd: function (e) {\n            // ðŸ‚namespace Editable\n            // ðŸ‚section Vertex events\n            // ðŸ‚event editable:vertex:dragend: VertexEvent\n            // Fired after a vertex is dragged by user.\n            this.fireAndForward('editable:vertex:dragend', e);\n        },\n\n        setDrawnLatLngs: function (latlngs) {\n            this._drawnLatLngs = latlngs || this.getDefaultLatLngs();\n        },\n\n        startDrawing: function () {\n            if (!this._drawnLatLngs) this.setDrawnLatLngs();\n            L.Editable.BaseEditor.prototype.startDrawing.call(this);\n        },\n\n        startDrawingForward: function () {\n            this.startDrawing();\n        },\n\n        endDrawing: function () {\n            this.tools.detachForwardLineGuide();\n            this.tools.detachBackwardLineGuide();\n            if (this._drawnLatLngs && this._drawnLatLngs.length < this.MIN_VERTEX) this.deleteShape(this._drawnLatLngs);\n            L.Editable.BaseEditor.prototype.endDrawing.call(this);\n            delete this._drawnLatLngs;\n        },\n\n        addLatLng: function (latlng) {\n            if (this._drawing === L.Editable.FORWARD) this._drawnLatLngs.push(latlng);\n            else this._drawnLatLngs.unshift(latlng);\n            this.feature._bounds.extend(latlng);\n            this.addVertexMarker(latlng, this._drawnLatLngs);\n            this.refresh();\n        },\n\n        newPointForward: function (latlng) {\n            this.addLatLng(latlng);\n            this.tools.attachForwardLineGuide();\n            this.tools.anchorForwardLineGuide(latlng);\n        },\n\n        newPointBackward: function (latlng) {\n            this.addLatLng(latlng);\n            this.tools.anchorBackwardLineGuide(latlng);\n        },\n\n        // ðŸ‚namespace PathEditor\n        // ðŸ‚method push()\n        // Programmatically add a point while drawing.\n        push: function (latlng) {\n            if (!latlng) return console.error('L.Editable.PathEditor.push expect a vaild latlng as parameter');\n            if (this._drawing === L.Editable.FORWARD) this.newPointForward(latlng);\n            else this.newPointBackward(latlng);\n        },\n\n        removeLatLng: function (latlng) {\n            latlng.__vertex.delete();\n            this.refresh();\n        },\n\n        // ðŸ‚method pop(): L.LatLng or null\n        // Programmatically remove last point (if any) while drawing.\n        pop: function () {\n            if (this._drawnLatLngs.length <= 1) return;\n            var latlng;\n            if (this._drawing === L.Editable.FORWARD) latlng = this._drawnLatLngs[this._drawnLatLngs.length - 1];\n            else latlng = this._drawnLatLngs[0];\n            this.removeLatLng(latlng);\n            if (this._drawing === L.Editable.FORWARD) this.tools.anchorForwardLineGuide(this._drawnLatLngs[this._drawnLatLngs.length - 1]);\n            else this.tools.anchorForwardLineGuide(this._drawnLatLngs[0]);\n            return latlng;\n        },\n\n        processDrawingClick: function (e) {\n            if (e.vertex && e.vertex.editor === this) return;\n            if (this._drawing === L.Editable.FORWARD) this.newPointForward(e.latlng);\n            else this.newPointBackward(e.latlng);\n            this.fireAndForward('editable:drawing:clicked', e);\n        },\n\n        onDrawingMouseMove: function (e) {\n            L.Editable.BaseEditor.prototype.onDrawingMouseMove.call(this, e);\n            if (this._drawing) {\n                this.tools.moveForwardLineGuide(e.latlng);\n                this.tools.moveBackwardLineGuide(e.latlng);\n            }\n        },\n\n        refresh: function () {\n            this.feature.redraw();\n            this.onEditing();\n        },\n\n        // ðŸ‚namespace PathEditor\n        // ðŸ‚method newShape(latlng?: L.LatLng)\n        // Add a new shape (Polyline, Polygon) in a multi, and setup up drawing tools to draw it;\n        // if optional `latlng` is given, start a path at this point.\n        newShape: function (latlng) {\n            var shape = this.addNewEmptyShape();\n            if (!shape) return;\n            this.setDrawnLatLngs(shape[0] || shape);  // Polygon or polyline\n            this.startDrawingForward();\n            // ðŸ‚namespace Editable\n            // ðŸ‚section Shape events\n            // ðŸ‚event editable:shape:new: ShapeEvent\n            // Fired when a new shape is created in a multi (Polygon or Polyline).\n            this.fireAndForward('editable:shape:new', {shape: shape});\n            if (latlng) this.newPointForward(latlng);\n        },\n\n        deleteShape: function (shape, latlngs) {\n            var e = {shape: shape};\n            L.Editable.makeCancellable(e);\n            // ðŸ‚namespace Editable\n            // ðŸ‚section Shape events\n            // ðŸ‚event editable:shape:delete: CancelableShapeEvent\n            // Fired before a new shape is deleted in a multi (Polygon or Polyline).\n            this.fireAndForward('editable:shape:delete', e);\n            if (e._cancelled) return;\n            shape = this._deleteShape(shape, latlngs);\n            if (this.ensureNotFlat) this.ensureNotFlat();  // Polygon.\n            this.feature.setLatLngs(this.getLatLngs());  // Force bounds reset.\n            this.refresh();\n            this.reset();\n            // ðŸ‚namespace Editable\n            // ðŸ‚section Shape events\n            // ðŸ‚event editable:shape:deleted: ShapeEvent\n            // Fired after a new shape is deleted in a multi (Polygon or Polyline).\n            this.fireAndForward('editable:shape:deleted', {shape: shape});\n            return shape;\n        },\n\n        _deleteShape: function (shape, latlngs) {\n            latlngs = latlngs || this.getLatLngs();\n            if (!latlngs.length) return;\n            var self = this,\n                inplaceDelete = function (latlngs, shape) {\n                    // Called when deleting a flat latlngs\n                    shape = latlngs.splice(0, Number.MAX_VALUE);\n                    return shape;\n                },\n                spliceDelete = function (latlngs, shape) {\n                    // Called when removing a latlngs inside an array\n                    latlngs.splice(latlngs.indexOf(shape), 1);\n                    if (!latlngs.length) self._deleteShape(latlngs);\n                    return shape;\n                };\n            if (latlngs === shape) return inplaceDelete(latlngs, shape);\n            for (var i = 0; i < latlngs.length; i++) {\n                if (latlngs[i] === shape) return spliceDelete(latlngs, shape);\n                else if (latlngs[i].indexOf(shape) !== -1) return spliceDelete(latlngs[i], shape);\n            }\n        },\n\n        // ðŸ‚namespace PathEditor\n        // ðŸ‚method deleteShapeAt(latlng: L.LatLng): Array\n        // Remove a path shape at the given `latlng`.\n        deleteShapeAt: function (latlng) {\n            var shape = this.feature.shapeAt(latlng);\n            if (shape) return this.deleteShape(shape);\n        },\n\n        // ðŸ‚method appendShape(shape: Array)\n        // Append a new shape to the Polygon or Polyline.\n        appendShape: function (shape) {\n            this.insertShape(shape);\n        },\n\n        // ðŸ‚method prependShape(shape: Array)\n        // Prepend a new shape to the Polygon or Polyline.\n        prependShape: function (shape) {\n            this.insertShape(shape, 0);\n        },\n\n        // ðŸ‚method insertShape(shape: Array, index: int)\n        // Insert a new shape to the Polygon or Polyline at given index (default is to append).\n        insertShape: function (shape, index) {\n            this.ensureMulti();\n            shape = this.formatShape(shape);\n            if (typeof index === 'undefined') index = this.feature._latlngs.length;\n            this.feature._latlngs.splice(index, 0, shape);\n            this.feature.redraw();\n            if (this._enabled) this.reset();\n        },\n\n        extendBounds: function (e) {\n            this.feature._bounds.extend(e.vertex.latlng);\n        },\n\n        onDragStart: function (e) {\n            this.editLayer.clearLayers();\n            L.Editable.BaseEditor.prototype.onDragStart.call(this, e);\n        },\n\n        onDragEnd: function (e) {\n            this.initVertexMarkers();\n            L.Editable.BaseEditor.prototype.onDragEnd.call(this, e);\n        }\n\n    });\n\n    // ðŸ‚namespace Editable; ðŸ‚class PolylineEditor; ðŸ‚aka L.Editable.PolylineEditor\n    // ðŸ‚inherits PathEditor\n    L.Editable.PolylineEditor = L.Editable.PathEditor.extend({\n\n        startDrawingBackward: function () {\n            this._drawing = L.Editable.BACKWARD;\n            this.startDrawing();\n        },\n\n        // ðŸ‚method continueBackward(latlngs?: Array)\n        // Set up drawing tools to continue the line backward.\n        continueBackward: function (latlngs) {\n            if (this.drawing()) return;\n            latlngs = latlngs || this.getDefaultLatLngs();\n            this.setDrawnLatLngs(latlngs);\n            if (latlngs.length > 0) {\n                this.tools.attachBackwardLineGuide();\n                this.tools.anchorBackwardLineGuide(latlngs[0]);\n            }\n            this.startDrawingBackward();\n        },\n\n        // ðŸ‚method continueForward(latlngs?: Array)\n        // Set up drawing tools to continue the line forward.\n        continueForward: function (latlngs) {\n            if (this.drawing()) return;\n            latlngs = latlngs || this.getDefaultLatLngs();\n            this.setDrawnLatLngs(latlngs);\n            if (latlngs.length > 0) {\n                this.tools.attachForwardLineGuide();\n                this.tools.anchorForwardLineGuide(latlngs[latlngs.length - 1]);\n            }\n            this.startDrawingForward();\n        },\n\n        getDefaultLatLngs: function (latlngs) {\n            latlngs = latlngs || this.feature._latlngs;\n            if (!latlngs.length || latlngs[0] instanceof L.LatLng) return latlngs;\n            else return this.getDefaultLatLngs(latlngs[0]);\n        },\n\n        ensureMulti: function () {\n            if (this.feature._latlngs.length && L.Polyline._flat(this.feature._latlngs)) {\n                this.feature._latlngs = [this.feature._latlngs];\n            }\n        },\n\n        addNewEmptyShape: function () {\n            if (this.feature._latlngs.length) {\n                var shape = [];\n                this.appendShape(shape);\n                return shape;\n            } else {\n                return this.feature._latlngs;\n            }\n        },\n\n        formatShape: function (shape) {\n            if (L.Polyline._flat(shape)) return shape;\n            else if (shape[0]) return this.formatShape(shape[0]);\n        },\n\n        // ðŸ‚method splitShape(latlngs?: Array, index: int)\n        // Split the given `latlngs` shape at index `index` and integrate new shape in instance `latlngs`.\n        splitShape: function (shape, index) {\n            if (!index || index >= shape.length - 1) return;\n            this.ensureMulti();\n            var shapeIndex = this.feature._latlngs.indexOf(shape);\n            if (shapeIndex === -1) return;\n            var first = shape.slice(0, index + 1),\n                second = shape.slice(index);\n            // We deal with reference, we don't want twice the same latlng around.\n            second[0] = L.latLng(second[0].lat, second[0].lng, second[0].alt);\n            this.feature._latlngs.splice(shapeIndex, 1, first, second);\n            this.refresh();\n            this.reset();\n        }\n\n    });\n\n    // ðŸ‚namespace Editable; ðŸ‚class PolygonEditor; ðŸ‚aka L.Editable.PolygonEditor\n    // ðŸ‚inherits PathEditor\n    L.Editable.PolygonEditor = L.Editable.PathEditor.extend({\n\n        CLOSED: true,\n        MIN_VERTEX: 3,\n\n        newPointForward: function (latlng) {\n            L.Editable.PathEditor.prototype.newPointForward.call(this, latlng);\n            if (!this.tools.backwardLineGuide._latlngs.length) this.tools.anchorBackwardLineGuide(latlng);\n            if (this._drawnLatLngs.length === 2) this.tools.attachBackwardLineGuide();\n        },\n\n        addNewEmptyHole: function (latlng) {\n            this.ensureNotFlat();\n            var latlngs = this.feature.shapeAt(latlng);\n            if (!latlngs) return;\n            var holes = [];\n            latlngs.push(holes);\n            return holes;\n        },\n\n        // ðŸ‚method newHole(latlng?: L.LatLng, index: int)\n        // Set up drawing tools for creating a new hole on the Polygon. If the `latlng` param is given, a first point is created.\n        newHole: function (latlng) {\n            var holes = this.addNewEmptyHole(latlng);\n            if (!holes) return;\n            this.setDrawnLatLngs(holes);\n            this.startDrawingForward();\n            if (latlng) this.newPointForward(latlng);\n        },\n\n        addNewEmptyShape: function () {\n            if (this.feature._latlngs.length && this.feature._latlngs[0].length) {\n                var shape = [];\n                this.appendShape(shape);\n                return shape;\n            } else {\n                return this.feature._latlngs;\n            }\n        },\n\n        ensureMulti: function () {\n            if (this.feature._latlngs.length && L.Polyline._flat(this.feature._latlngs[0])) {\n                this.feature._latlngs = [this.feature._latlngs];\n            }\n        },\n\n        ensureNotFlat: function () {\n            if (!this.feature._latlngs.length || L.Polyline._flat(this.feature._latlngs)) this.feature._latlngs = [this.feature._latlngs];\n        },\n\n        vertexCanBeDeleted: function (vertex) {\n            var parent = this.feature.parentShape(vertex.latlngs),\n                idx = L.Util.indexOf(parent, vertex.latlngs);\n            if (idx > 0) return true;  // Holes can be totally deleted without removing the layer itself.\n            return L.Editable.PathEditor.prototype.vertexCanBeDeleted.call(this, vertex);\n        },\n\n        getDefaultLatLngs: function () {\n            if (!this.feature._latlngs.length) this.feature._latlngs.push([]);\n            return this.feature._latlngs[0];\n        },\n\n        formatShape: function (shape) {\n            // [[1, 2], [3, 4]] => must be nested\n            // [] => must be nested\n            // [[]] => is already nested\n            if (L.Polyline._flat(shape) && (!shape[0] || shape[0].length !== 0)) return [shape];\n            else return shape;\n        }\n\n    });\n\n    // ðŸ‚namespace Editable; ðŸ‚class RectangleEditor; ðŸ‚aka L.Editable.RectangleEditor\n    // ðŸ‚inherits PathEditor\n    L.Editable.RectangleEditor = L.Editable.PathEditor.extend({\n\n        CLOSED: true,\n        MIN_VERTEX: 4,\n\n        options: {\n            skipMiddleMarkers: true\n        },\n\n        extendBounds: function (e) {\n            var index = e.vertex.getIndex(),\n                next = e.vertex.getNext(),\n                previous = e.vertex.getPrevious(),\n                oppositeIndex = (index + 2) % 4,\n                opposite = e.vertex.latlngs[oppositeIndex],\n                bounds = new L.LatLngBounds(e.latlng, opposite);\n            // Update latlngs by hand to preserve order.\n            previous.latlng.update([e.latlng.lat, opposite.lng]);\n            next.latlng.update([opposite.lat, e.latlng.lng]);\n            this.updateBounds(bounds);\n            this.refreshVertexMarkers();\n        },\n\n        onDrawingMouseDown: function (e) {\n            L.Editable.PathEditor.prototype.onDrawingMouseDown.call(this, e);\n            this.connect();\n            var latlngs = this.getDefaultLatLngs();\n            // L.Polygon._convertLatLngs removes last latlng if it equals first point,\n            // which is the case here as all latlngs are [0, 0]\n            if (latlngs.length === 3) latlngs.push(e.latlng);\n            var bounds = new L.LatLngBounds(e.latlng, e.latlng);\n            this.updateBounds(bounds);\n            this.updateLatLngs(bounds);\n            this.refresh();\n            this.reset();\n            // Stop dragging map.\n            // L.Draggable has two workflows:\n            // - mousedown => mousemove => mouseup\n            // - touchstart => touchmove => touchend\n            // Problem: L.Map.Tap does not allow us to listen to touchstart, so we only\n            // can deal with mousedown, but then when in a touch device, we are dealing with\n            // simulated events (actually simulated by L.Map.Tap), which are no more taken\n            // into account by L.Draggable.\n            // Ref.: https://github.com/Leaflet/Leaflet.Editable/issues/103\n            e.originalEvent._simulated = false;\n            this.map.dragging._draggable._onUp(e.originalEvent);\n            // Now transfer ongoing drag action to the bottom right corner.\n            // Should we refine which corne will handle the drag according to\n            // drag direction?\n            latlngs[3].__vertex.dragging._draggable._onDown(e.originalEvent);\n        },\n\n        onDrawingMouseUp: function (e) {\n            this.commitDrawing(e);\n            e.originalEvent._simulated = false;\n            L.Editable.PathEditor.prototype.onDrawingMouseUp.call(this, e);\n        },\n\n        onDrawingMouseMove: function (e) {\n            e.originalEvent._simulated = false;\n            L.Editable.PathEditor.prototype.onDrawingMouseMove.call(this, e);\n        },\n\n\n        getDefaultLatLngs: function (latlngs) {\n            return latlngs || this.feature._latlngs[0];\n        },\n\n        updateBounds: function (bounds) {\n            this.feature._bounds = bounds;\n        },\n\n        updateLatLngs: function (bounds) {\n            var latlngs = this.getDefaultLatLngs(),\n                newLatlngs = this.feature._boundsToLatLngs(bounds);\n            // Keep references.\n            for (var i = 0; i < latlngs.length; i++) {\n                latlngs[i].update(newLatlngs[i]);\n            };\n        }\n\n    });\n\n    // ðŸ‚namespace Editable; ðŸ‚class CircleEditor; ðŸ‚aka L.Editable.CircleEditor\n    // ðŸ‚inherits PathEditor\n    L.Editable.CircleEditor = L.Editable.PathEditor.extend({\n\n        MIN_VERTEX: 2,\n\n        options: {\n            skipMiddleMarkers: true\n        },\n\n        initialize: function (map, feature, options) {\n            L.Editable.PathEditor.prototype.initialize.call(this, map, feature, options);\n            this._resizeLatLng = this.computeResizeLatLng();\n        },\n\n        computeResizeLatLng: function () {\n            // While circle is not added to the map, _radius is not set.\n            var delta = (this.feature._radius || this.feature._mRadius) * Math.cos(Math.PI / 4),\n                point = this.map.project(this.feature._latlng);\n            return this.map.unproject([point.x + delta, point.y - delta]);\n        },\n\n        updateResizeLatLng: function () {\n            this._resizeLatLng.update(this.computeResizeLatLng());\n            this._resizeLatLng.__vertex.update();\n        },\n\n        getLatLngs: function () {\n            return [this.feature._latlng, this._resizeLatLng];\n        },\n\n        getDefaultLatLngs: function () {\n            return this.getLatLngs();\n        },\n\n        onVertexMarkerDrag: function (e) {\n            if (e.vertex.getIndex() === 1) this.resize(e);\n            else this.updateResizeLatLng(e);\n            L.Editable.PathEditor.prototype.onVertexMarkerDrag.call(this, e);\n        },\n\n        resize: function (e) {\n            var radius = this.feature._latlng.distanceTo(e.latlng)\n            this.feature.setRadius(radius);\n        },\n\n        onDrawingMouseDown: function (e) {\n            L.Editable.PathEditor.prototype.onDrawingMouseDown.call(this, e);\n            this._resizeLatLng.update(e.latlng);\n            this.feature._latlng.update(e.latlng);\n            this.connect();\n            // Stop dragging map.\n            e.originalEvent._simulated = false;\n            this.map.dragging._draggable._onUp(e.originalEvent);\n            // Now transfer ongoing drag action to the radius handler.\n            this._resizeLatLng.__vertex.dragging._draggable._onDown(e.originalEvent);\n        },\n\n        onDrawingMouseUp: function (e) {\n            this.commitDrawing(e);\n            e.originalEvent._simulated = false;\n            L.Editable.PathEditor.prototype.onDrawingMouseUp.call(this, e);\n        },\n\n        onDrawingMouseMove: function (e) {\n            e.originalEvent._simulated = false;\n            L.Editable.PathEditor.prototype.onDrawingMouseMove.call(this, e);\n        },\n\n        onDrag: function (e) {\n            L.Editable.PathEditor.prototype.onDrag.call(this, e);\n            this.feature.dragging.updateLatLng(this._resizeLatLng);\n        }\n\n    });\n\n    // ðŸ‚namespace Editable; ðŸ‚class EditableMixin\n    // `EditableMixin` is included to `L.Polyline`, `L.Polygon`, `L.Rectangle`, `L.Circle`\n    //Â and `L.Marker`. It adds some methods to them.\n    // *When editing is enabled, the editor is accessible on the instance with the\n    // `editor` property.*\n    var EditableMixin = {\n\n        createEditor: function (map) {\n            map = map || this._map;\n            var tools = (this.options.editOptions || {}).editTools || map.editTools;\n            if (!tools) throw Error('Unable to detect Editable instance.')\n            var Klass = this.options.editorClass || this.getEditorClass(tools);\n            return new Klass(map, this, this.options.editOptions);\n        },\n\n        // ðŸ‚method enableEdit(map?: L.Map): this.editor\n        // Enable editing, by creating an editor if not existing, and then calling `enable` on it.\n        enableEdit: function (map) {\n            if (!this.editor) this.createEditor(map);\n            this.editor.enable();\n            return this.editor;\n        },\n\n        // ðŸ‚method editEnabled(): boolean\n        // Return true if current instance has an editor attached, and this editor is enabled.\n        editEnabled: function () {\n            return this.editor && this.editor.enabled();\n        },\n\n        // ðŸ‚method disableEdit()\n        // Disable editing, also remove the editor property reference.\n        disableEdit: function () {\n            if (this.editor) {\n                this.editor.disable();\n                delete this.editor;\n            }\n        },\n\n        // ðŸ‚method toggleEdit()\n        // Enable or disable editing, according to current status.\n        toggleEdit: function () {\n            if (this.editEnabled()) this.disableEdit();\n            else this.enableEdit();\n        },\n\n        _onEditableAdd: function () {\n            if (this.editor) this.enableEdit();\n        }\n\n    };\n\n    var PolylineMixin = {\n\n        getEditorClass: function (tools) {\n            return (tools && tools.options.polylineEditorClass) ? tools.options.polylineEditorClass : L.Editable.PolylineEditor;\n        },\n\n        shapeAt: function (latlng, latlngs) {\n            // We can have those cases:\n            // - latlngs are just a flat array of latlngs, use this\n            // - latlngs is an array of arrays of latlngs, loop over\n            var shape = null;\n            latlngs = latlngs || this._latlngs;\n            if (!latlngs.length) return shape;\n            else if (L.Polyline._flat(latlngs) && this.isInLatLngs(latlng, latlngs)) shape = latlngs;\n            else for (var i = 0; i < latlngs.length; i++) if (this.isInLatLngs(latlng, latlngs[i])) return latlngs[i];\n            return shape;\n        },\n\n        isInLatLngs: function (l, latlngs) {\n            if (!latlngs) return false;\n            var i, k, len, part = [], p,\n                w = this._clickTolerance();\n            this._projectLatlngs(latlngs, part, this._pxBounds);\n            part = part[0];\n            p = this._map.latLngToLayerPoint(l);\n\n            if (!this._pxBounds.contains(p)) { return false; }\n            for (i = 1, len = part.length, k = 0; i < len; k = i++) {\n\n                if (L.LineUtil.pointToSegmentDistance(p, part[k], part[i]) <= w) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n    };\n\n    var PolygonMixin = {\n\n        getEditorClass: function (tools) {\n            return (tools && tools.options.polygonEditorClass) ? tools.options.polygonEditorClass : L.Editable.PolygonEditor;\n        },\n\n        shapeAt: function (latlng, latlngs) {\n            // We can have those cases:\n            // - latlngs are just a flat array of latlngs, use this\n            // - latlngs is an array of arrays of latlngs, this is a simple polygon (maybe with holes), use the first\n            // - latlngs is an array of arrays of arrays, this is a multi, loop over\n            var shape = null;\n            latlngs = latlngs || this._latlngs;\n            if (!latlngs.length) return shape;\n            else if (L.Polyline._flat(latlngs) && this.isInLatLngs(latlng, latlngs)) shape = latlngs;\n            else if (L.Polyline._flat(latlngs[0]) && this.isInLatLngs(latlng, latlngs[0])) shape = latlngs;\n            else for (var i = 0; i < latlngs.length; i++) if (this.isInLatLngs(latlng, latlngs[i][0])) return latlngs[i];\n            return shape;\n        },\n\n        isInLatLngs: function (l, latlngs) {\n            var inside = false, l1, l2, j, k, len2;\n\n            for (j = 0, len2 = latlngs.length, k = len2 - 1; j < len2; k = j++) {\n                l1 = latlngs[j];\n                l2 = latlngs[k];\n\n                if (((l1.lat > l.lat) !== (l2.lat > l.lat)) &&\n                        (l.lng < (l2.lng - l1.lng) * (l.lat - l1.lat) / (l2.lat - l1.lat) + l1.lng)) {\n                    inside = !inside;\n                }\n            }\n\n            return inside;\n        },\n\n        parentShape: function (shape, latlngs) {\n            latlngs = latlngs || this._latlngs;\n            if (!latlngs) return;\n            var idx = L.Util.indexOf(latlngs, shape);\n            if (idx !== -1) return latlngs;\n            for (var i = 0; i < latlngs.length; i++) {\n                idx = L.Util.indexOf(latlngs[i], shape);\n                if (idx !== -1) return latlngs[i];\n            }\n        }\n\n    };\n\n\n    var MarkerMixin = {\n\n        getEditorClass: function (tools) {\n            return (tools && tools.options.markerEditorClass) ? tools.options.markerEditorClass : L.Editable.MarkerEditor;\n        }\n\n    };\n\n    var RectangleMixin = {\n\n        getEditorClass: function (tools) {\n            return (tools && tools.options.rectangleEditorClass) ? tools.options.rectangleEditorClass : L.Editable.RectangleEditor;\n        }\n\n    };\n\n    var CircleMixin = {\n\n        getEditorClass: function (tools) {\n            return (tools && tools.options.circleEditorClass) ? tools.options.circleEditorClass : L.Editable.CircleEditor;\n        }\n\n    };\n\n    var keepEditable = function () {\n        // Make sure you can remove/readd an editable layer.\n        this.on('add', this._onEditableAdd);\n    };\n\n\n\n    if (L.Polyline) {\n        L.Polyline.include(EditableMixin);\n        L.Polyline.include(PolylineMixin);\n        L.Polyline.addInitHook(keepEditable);\n    }\n    if (L.Polygon) {\n        L.Polygon.include(EditableMixin);\n        L.Polygon.include(PolygonMixin);\n    }\n    if (L.Marker) {\n        L.Marker.include(EditableMixin);\n        L.Marker.include(MarkerMixin);\n        L.Marker.addInitHook(keepEditable);\n    }\n    if (L.Rectangle) {\n        L.Rectangle.include(EditableMixin);\n        L.Rectangle.include(RectangleMixin);\n    }\n    if (L.Circle) {\n        L.Circle.include(EditableMixin);\n        L.Circle.include(CircleMixin);\n    }\n\n    L.LatLng.prototype.update = function (latlng) {\n        latlng = L.latLng(latlng);\n        this.lat = latlng.lat;\n        this.lng = latlng.lng;\n    }\n\n}, window));\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/* A Draggable that does not update the element position\nand takes care of only bubbling to targetted path in Canvas mode. */\nL.PathDraggable = L.Draggable.extend({\n\n  initialize: function (path) {\n    this._path = path;\n    this._canvas = (path._map.getRenderer(path) instanceof L.Canvas);\n    var element = this._canvas ? this._path._map.getRenderer(this._path)._container : this._path._path;\n    L.Draggable.prototype.initialize.call(this, element, element, true);\n  },\n\n  _updatePosition: function () {\n    var e = {originalEvent: this._lastEvent};\n    this.fire('drag', e);\n  },\n\n  _onDown: function (e) {\n    var first = e.touches ? e.touches[0] : e;\n    this._startPoint = new L.Point(first.clientX, first.clientY);\n    if (this._canvas && !this._path._containsPoint(this._path._map.mouseEventToLayerPoint(first))) { return; }\n    L.Draggable.prototype._onDown.call(this, e);\n  }\n\n});\n\n\nL.Handler.PathDrag = L.Handler.extend({\n\n  initialize: function (path) {\n    this._path = path;\n  },\n\n  getEvents: function () {\n    return {\n      dragstart: this._onDragStart,\n      drag: this._onDrag,\n      dragend: this._onDragEnd\n    };\n  },\n\n  addHooks: function () {\n    if (!this._draggable) { this._draggable = new L.PathDraggable(this._path); }\n    this._draggable.on(this.getEvents(), this).enable();\n    L.DomUtil.addClass(this._draggable._element, 'leaflet-path-draggable');\n  },\n\n  removeHooks: function () {\n    this._draggable.off(this.getEvents(), this).disable();\n    L.DomUtil.removeClass(this._draggable._element, 'leaflet-path-draggable');\n  },\n\n  moved: function () {\n    return this._draggable && this._draggable._moved;\n  },\n\n  _onDragStart: function () {\n    this._startPoint = this._draggable._startPoint;\n    this._path\n        .closePopup()\n        .fire('movestart')\n        .fire('dragstart');\n  },\n\n  _onDrag: function (e) {\n    var path = this._path,\n        event = (e.originalEvent.touches && e.originalEvent.touches.length === 1 ? e.originalEvent.touches[0] : e.originalEvent),\n        newPoint = L.point(event.clientX, event.clientY),\n        latlng = path._map.layerPointToLatLng(newPoint);\n\n    this._offset = newPoint.subtract(this._startPoint);\n    this._startPoint = newPoint;\n\n    this._path.eachLatLng(this.updateLatLng, this);\n    path.redraw();\n\n    e.latlng = latlng;\n    e.offset = this._offset;\n    path.fire('move', e)\n        .fire('drag', e);\n  },\n\n  _onDragEnd: function (e) {\n    if (this._path._bounds) this.resetBounds();\n    this._path.fire('moveend')\n        .fire('dragend', e);\n  },\n\n  latLngToLayerPoint: function (latlng) {\n    // Same as map.latLngToLayerPoint, but without the round().\n    var projectedPoint = this._path._map.project(L.latLng(latlng));\n    return projectedPoint._subtract(this._path._map.getPixelOrigin());\n  },\n\n  updateLatLng: function (latlng) {\n    var oldPoint = this.latLngToLayerPoint(latlng);\n    oldPoint._add(this._offset);\n    var newLatLng = this._path._map.layerPointToLatLng(oldPoint);\n    latlng.lat = newLatLng.lat;\n    latlng.lng = newLatLng.lng;\n  },\n\n  resetBounds: function () {\n    this._path._bounds = new L.LatLngBounds();\n    this._path.eachLatLng(function (latlng) {\n      this._bounds.extend(latlng);\n    });\n  }\n\n});\n\nL.Path.include({\n\n  eachLatLng: function (callback, context) {\n    context = context || this;\n    var loop = function (latlngs) {\n      for (var i = 0; i < latlngs.length; i++) {\n        if (L.Util.isArray(latlngs[i])) loop(latlngs[i]);\n        else callback.call(context, latlngs[i]);\n      }\n    };\n    loop(this.getLatLngs ? this.getLatLngs() : [this.getLatLng()]);\n  }\n\n});\n\nL.Path.addInitHook(function () {\n\n  this.dragging = new L.Handler.PathDrag(this);\n  if (this.options.draggable) {\n    this.once('add', function () {\n      this.dragging.enable();\n    });\n  }\n\n});\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(1);\n\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// Limapper.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 3cf20a5263f2f54c6d08","module.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"L\"\n// module id = 0\n// module chunks = 0","import L from 'leaflet';\nrequire('leaflet.path.drag');\nrequire('leaflet-editable');\n\n/**\n * Leaflet Image Mapper\n */\nexport default class Limapper {\n  /**\n   * initialize object\n   * @return {object} Instance\n   */\n  constructor() {\n    this._name = 'Limapper';\n  }\n\n  /**\n   * get name\n   * @return {string} name\n   */\n  get name() {\n    return this._name;\n  }\n\n  /**\n   * get items\n   * @return {Array} list of items\n   */\n  get items() {\n    let self = this;\n\n    if (!self._map) {\n      return [];\n    }\n\n    let items = [];\n    let map = self._map;\n    let po = map.latLngToLayerPoint(new L.LatLng(0, 0));\n\n    map.eachLayer((v, k) => {\n      // handle rectangle\n      if (v.editor instanceof L.Editable.RectangleEditor) {\n        if (v._bounds) {\n          if (!v.mydata) {\n            v.mydata = {rect: {}};\n          }\n          let nw = map.latLngToLayerPoint(v._bounds.getNorthWest());\n          let se = map.latLngToLayerPoint(v._bounds.getSouthEast());\n\n          v.mydata.rect.x1 = nw.x - po.x;\n          v.mydata.rect.x2 = se.x - po.x;\n          v.mydata.rect.y1 = nw.y - po.y;\n          v.mydata.rect.y2 = se.y - po.y;\n          items.push(v);\n        }\n      }\n\n    });\n\n    return items;\n  }\n\n  /**\n   * initialize object\n   * @param  {object} opts options\n   * @return {object}      self\n   */\n  init(opts) {\n    let self = this;\n    let defs = {\n      minZoom: 1,\n      maxZoom: 5,\n      center: [0, 0],\n      zoom: 1,\n      editable: true,\n      crs: L.CRS.Simple\n    };\n    let southWest, northEast, bounds, map;\n\n    // apply defaults\n    for (let k in defs) {\n      opts[k] = opts[k] || defs[k];\n    }\n    map = L.map(opts.elid || 'map', opts);\n    southWest = map.unproject([0, opts.imageHeight]);\n    northEast = map.unproject([opts.imageWidth, 0]);\n    bounds = new L.LatLngBounds(southWest, northEast);\n    L.imageOverlay(opts.imageUrl, bounds).addTo(map);\n    map.setMaxBounds(bounds);\n    this._map = map;\n\n    L.EditControl = L.Control.extend({\n      options: {\n        position: 'topleft',\n        callback: null,\n        kind: '',\n        html: ''\n      },\n      onAdd: function (map) {\n        let container = L.DomUtil.create('div', 'leaflet-control leaflet-bar'),\n          link = L.DomUtil.create('a', '', container);\n\n        link.href = '#';\n        link.title = 'Create a new ' + this.options.kind;\n        link.innerHTML = this.options.html;\n        L.DomEvent\n          .on(link, 'click', L.DomEvent.stop)\n          .on(link, 'click', function () {\n            window.LAYER = this.options.callback.call(map.editTools);\n          }, this);\n\n        return container;\n      }\n    });\n\n    map.on('layeradd', (e) => {\n      if (e.layer instanceof L.Path) {\n        // self._items.push(e.layer);\n        setTimeout(() => {\n          self.items();\n        }, 100);\n      }\n    });\n\n    L.NewRectangleControl = L.EditControl.extend({\n      options: {\n        position: 'topleft',\n        callback: map.editTools.startRectangle,\n        kind: 'rect',\n        html: 'â¬›'\n      }\n    });\n\n    map.addControl(new L.NewRectangleControl());\n\n    return self;\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","'use strict';\n(function (factory, window) {\n    /*globals define, module, require*/\n\n    // define an AMD module that relies on 'leaflet'\n    if (typeof define === 'function' && define.amd) {\n        define(['leaflet'], factory);\n\n\n    // define a Common JS module that relies on 'leaflet'\n    } else if (typeof exports === 'object') {\n        module.exports = factory(require('leaflet'));\n    }\n\n    // attach your plugin to the global 'L' variable\n    if(typeof window !== 'undefined' && window.L){\n        factory(window.L);\n    }\n\n}(function (L) {\n    // ðŸ‚miniclass CancelableEvent (Event objects)\n    // ðŸ‚method cancel()\n    // Cancel any subsequent action.\n\n    // ðŸ‚miniclass VertexEvent (Event objects)\n    // ðŸ‚property vertex: VertexMarker\n    // The vertex that fires the event.\n\n    // ðŸ‚miniclass ShapeEvent (Event objects)\n    // ðŸ‚property shape: Array\n    // The shape (LatLngs array) subject of the action.\n\n    // ðŸ‚miniclass CancelableVertexEvent (Event objects)\n    // ðŸ‚inherits VertexEvent\n    // ðŸ‚inherits CancelableEvent\n\n    // ðŸ‚miniclass CancelableShapeEvent (Event objects)\n    // ðŸ‚inherits ShapeEvent\n    // ðŸ‚inherits CancelableEvent\n\n    // ðŸ‚miniclass LayerEvent (Event objects)\n    // ðŸ‚property layer: object\n    // The Layer (Marker, Polylineâ€¦) subject of the action.\n\n    // ðŸ‚namespace Editable; ðŸ‚class Editable; ðŸ‚aka L.Editable\n    // Main edition handler. By default, it is attached to the map\n    // as `map.editTools` property.\n    // Leaflet.Editable is made to be fully extendable. You have three ways to customize\n    // the behaviour: using options, listening to events, or extending.\n    L.Editable = L.Evented.extend({\n\n        statics: {\n            FORWARD: 1,\n            BACKWARD: -1\n        },\n\n        options: {\n\n            // You can pass them when creating a map using the `editOptions` key.\n            // ðŸ‚option zIndex: int = 1000\n            // The default zIndex of the editing tools.\n            zIndex: 1000,\n\n            // ðŸ‚option polygonClass: class = L.Polygon\n            // Class to be used when creating a new Polygon.\n            polygonClass: L.Polygon,\n\n            // ðŸ‚option polylineClass: class = L.Polyline\n            // Class to be used when creating a new Polyline.\n            polylineClass: L.Polyline,\n\n            // ðŸ‚option markerClass: class = L.Marker\n            // Class to be used when creating a new Marker.\n            markerClass: L.Marker,\n\n            // ðŸ‚option rectangleClass: class = L.Rectangle\n            // Class to be used when creating a new Rectangle.\n            rectangleClass: L.Rectangle,\n\n            // ðŸ‚option circleClass: class = L.Circle\n            // Class to be used when creating a new Circle.\n            circleClass: L.Circle,\n\n            // ðŸ‚option drawingCSSClass: string = 'leaflet-editable-drawing'\n            // CSS class to be added to the map container while drawing.\n            drawingCSSClass: 'leaflet-editable-drawing',\n\n            // ðŸ‚option drawingCursor: const = 'crosshair'\n            // Cursor mode set to the map while drawing.\n            drawingCursor: 'crosshair',\n\n            // ðŸ‚option editLayer: Layer = new L.LayerGroup()\n            // Layer used to store edit tools (vertex, line guideâ€¦).\n            editLayer: undefined,\n\n            // ðŸ‚option featuresLayer: Layer = new L.LayerGroup()\n            // Default layer used to store drawn features (Marker, Polylineâ€¦).\n            featuresLayer: undefined,\n\n            // ðŸ‚option polylineEditorClass: class = PolylineEditor\n            // Class to be used as Polyline editor.\n            polylineEditorClass: undefined,\n\n            // ðŸ‚option polygonEditorClass: class = PolygonEditor\n            // Class to be used as Polygon editor.\n            polygonEditorClass: undefined,\n\n            // ðŸ‚option markerEditorClass: class = MarkerEditor\n            // Class to be used as Marker editor.\n            markerEditorClass: undefined,\n\n            // ðŸ‚option rectangleEditorClass: class = RectangleEditor\n            // Class to be used as Rectangle editor.\n            rectangleEditorClass: undefined,\n\n            // ðŸ‚option circleEditorClass: class = CircleEditor\n            // Class to be used as Circle editor.\n            circleEditorClass: undefined,\n\n            // ðŸ‚option lineGuideOptions: hash = {}\n            // Options to be passed to the line guides.\n            lineGuideOptions: {},\n\n            // ðŸ‚option skipMiddleMarkers: boolean = false\n            // Set this to true if you don't want middle markers.\n            skipMiddleMarkers: false\n\n        },\n\n        initialize: function (map, options) {\n            L.setOptions(this, options);\n            this._lastZIndex = this.options.zIndex;\n            this.map = map;\n            this.editLayer = this.createEditLayer();\n            this.featuresLayer = this.createFeaturesLayer();\n            this.forwardLineGuide = this.createLineGuide();\n            this.backwardLineGuide = this.createLineGuide();\n        },\n\n        fireAndForward: function (type, e) {\n            e = e || {};\n            e.editTools = this;\n            this.fire(type, e);\n            this.map.fire(type, e);\n        },\n\n        createLineGuide: function () {\n            var options = L.extend({dashArray: '5,10', weight: 1, interactive: false}, this.options.lineGuideOptions);\n            return L.polyline([], options);\n        },\n\n        createVertexIcon: function (options) {\n            return L.Browser.touch ? new L.Editable.TouchVertexIcon(options) : new L.Editable.VertexIcon(options);\n        },\n\n        createEditLayer: function () {\n            return this.options.editLayer || new L.LayerGroup().addTo(this.map);\n        },\n\n        createFeaturesLayer: function () {\n            return this.options.featuresLayer || new L.LayerGroup().addTo(this.map);\n        },\n\n        moveForwardLineGuide: function (latlng) {\n            if (this.forwardLineGuide._latlngs.length) {\n                this.forwardLineGuide._latlngs[1] = latlng;\n                this.forwardLineGuide._bounds.extend(latlng);\n                this.forwardLineGuide.redraw();\n            }\n        },\n\n        moveBackwardLineGuide: function (latlng) {\n            if (this.backwardLineGuide._latlngs.length) {\n                this.backwardLineGuide._latlngs[1] = latlng;\n                this.backwardLineGuide._bounds.extend(latlng);\n                this.backwardLineGuide.redraw();\n            }\n        },\n\n        anchorForwardLineGuide: function (latlng) {\n            this.forwardLineGuide._latlngs[0] = latlng;\n            this.forwardLineGuide._bounds.extend(latlng);\n            this.forwardLineGuide.redraw();\n        },\n\n        anchorBackwardLineGuide: function (latlng) {\n            this.backwardLineGuide._latlngs[0] = latlng;\n            this.backwardLineGuide._bounds.extend(latlng);\n            this.backwardLineGuide.redraw();\n        },\n\n        attachForwardLineGuide: function () {\n            this.editLayer.addLayer(this.forwardLineGuide);\n        },\n\n        attachBackwardLineGuide: function () {\n            this.editLayer.addLayer(this.backwardLineGuide);\n        },\n\n        detachForwardLineGuide: function () {\n            this.forwardLineGuide.setLatLngs([]);\n            this.editLayer.removeLayer(this.forwardLineGuide);\n        },\n\n        detachBackwardLineGuide: function () {\n            this.backwardLineGuide.setLatLngs([]);\n            this.editLayer.removeLayer(this.backwardLineGuide);\n        },\n\n        blockEvents: function () {\n            // Hack: force map not to listen to other layers events while drawing.\n            if (!this._oldTargets) {\n                this._oldTargets = this.map._targets;\n                this.map._targets = {};\n            }\n        },\n\n        unblockEvents: function () {\n            if (this._oldTargets) {\n                // Reset, but keep targets created while drawing.\n                this.map._targets = L.extend(this.map._targets, this._oldTargets);\n                delete this._oldTargets;\n            }\n        },\n\n        registerForDrawing: function (editor) {\n            if (this._drawingEditor) this.unregisterForDrawing(this._drawingEditor);\n            this.blockEvents();\n            editor.reset();  // Make sure editor tools still receive events.\n            this._drawingEditor = editor;\n            this.map.on('mousemove touchmove', editor.onDrawingMouseMove, editor);\n            this.map.on('mousedown', this.onMousedown, this);\n            this.map.on('mouseup', this.onMouseup, this);\n            L.DomUtil.addClass(this.map._container, this.options.drawingCSSClass);\n            this.defaultMapCursor = this.map._container.style.cursor;\n            this.map._container.style.cursor = this.options.drawingCursor;\n        },\n\n        unregisterForDrawing: function (editor) {\n            this.unblockEvents();\n            L.DomUtil.removeClass(this.map._container, this.options.drawingCSSClass);\n            this.map._container.style.cursor = this.defaultMapCursor;\n            editor = editor || this._drawingEditor;\n            if (!editor) return;\n            this.map.off('mousemove touchmove', editor.onDrawingMouseMove, editor);\n            this.map.off('mousedown', this.onMousedown, this);\n            this.map.off('mouseup', this.onMouseup, this);\n            if (editor !== this._drawingEditor) return;\n            delete this._drawingEditor;\n            if (editor._drawing) editor.cancelDrawing();\n        },\n\n        onMousedown: function (e) {\n            this._mouseDown = e;\n            this._drawingEditor.onDrawingMouseDown(e);\n        },\n\n        onMouseup: function (e) {\n            if (this._mouseDown) {\n                var editor = this._drawingEditor,\n                    mouseDown = this._mouseDown;\n                this._mouseDown = null;\n                editor.onDrawingMouseUp(e);\n                if (this._drawingEditor !== editor) return;  // onDrawingMouseUp may call unregisterFromDrawing.\n                var origin = L.point(mouseDown.originalEvent.clientX, mouseDown.originalEvent.clientY);\n                var distance = L.point(e.originalEvent.clientX, e.originalEvent.clientY).distanceTo(origin);\n                if (Math.abs(distance) < 9 * (window.devicePixelRatio || 1)) this._drawingEditor.onDrawingClick(e);\n            }\n        },\n\n        // ðŸ‚section Public methods\n        // You will generally access them by the `map.editTools`\n        // instance:\n        //\n        // `map.editTools.startPolyline();`\n\n        // ðŸ‚method drawing(): boolean\n        // Return true if any drawing action is ongoing.\n        drawing: function () {\n            return this._drawingEditor && this._drawingEditor.drawing();\n        },\n\n        // ðŸ‚method stopDrawing()\n        // When you need to stop any ongoing drawing, without needing to know which editor is active.\n        stopDrawing: function () {\n            this.unregisterForDrawing();\n        },\n\n        // ðŸ‚method commitDrawing()\n        // When you need to commit any ongoing drawing, without needing to know which editor is active.\n        commitDrawing: function (e) {\n            if (!this._drawingEditor) return;\n            this._drawingEditor.commitDrawing(e);\n        },\n\n        connectCreatedToMap: function (layer) {\n            return this.featuresLayer.addLayer(layer);\n        },\n\n        // ðŸ‚method startPolyline(latlng: L.LatLng, options: hash): L.Polyline\n        // Start drawing a Polyline. If `latlng` is given, a first point will be added. In any case, continuing on user click.\n        // If `options` is given, it will be passed to the Polyline class constructor.\n        startPolyline: function (latlng, options) {\n            var line = this.createPolyline([], options);\n            line.enableEdit(this.map).newShape(latlng);\n            return line;\n        },\n\n        // ðŸ‚method startPolygon(latlng: L.LatLng, options: hash): L.Polygon\n        // Start drawing a Polygon. If `latlng` is given, a first point will be added. In any case, continuing on user click.\n        // If `options` is given, it will be passed to the Polygon class constructor.\n        startPolygon: function (latlng, options) {\n            var polygon = this.createPolygon([], options);\n            polygon.enableEdit(this.map).newShape(latlng);\n            return polygon;\n        },\n\n        // ðŸ‚method startMarker(latlng: L.LatLng, options: hash): L.Marker\n        // Start adding a Marker. If `latlng` is given, the Marker will be shown first at this point.\n        // In any case, it will follow the user mouse, and will have a final `latlng` on next click (or touch).\n        // If `options` is given, it will be passed to the Marker class constructor.\n        startMarker: function (latlng, options) {\n            latlng = latlng || this.map.getCenter().clone();\n            var marker = this.createMarker(latlng, options);\n            marker.enableEdit(this.map).startDrawing();\n            return marker;\n        },\n\n        // ðŸ‚method startRectangle(latlng: L.LatLng, options: hash): L.Rectangle\n        // Start drawing a Rectangle. If `latlng` is given, the Rectangle anchor will be added. In any case, continuing on user drag.\n        // If `options` is given, it will be passed to the Rectangle class constructor.\n        startRectangle: function(latlng, options) {\n            var corner = latlng || L.latLng([0, 0]);\n            var bounds = new L.LatLngBounds(corner, corner);\n            var rectangle = this.createRectangle(bounds, options);\n            rectangle.enableEdit(this.map).startDrawing();\n            return rectangle;\n        },\n\n        // ðŸ‚method startCircle(latlng: L.LatLng, options: hash): L.Circle\n        // Start drawing a Circle. If `latlng` is given, the Circle anchor will be added. In any case, continuing on user drag.\n        // If `options` is given, it will be passed to the Circle class constructor.\n        startCircle: function (latlng, options) {\n            latlng = latlng || this.map.getCenter().clone();\n            var circle = this.createCircle(latlng, options);\n            circle.enableEdit(this.map).startDrawing();\n            return circle;\n        },\n\n        startHole: function (editor, latlng) {\n            editor.newHole(latlng);\n        },\n\n        createLayer: function (klass, latlngs, options) {\n            options = L.Util.extend({editOptions: {editTools: this}}, options);\n            var layer = new klass(latlngs, options);\n            // ðŸ‚namespace Editable\n            // ðŸ‚event editable:created: LayerEvent\n            // Fired when a new feature (Marker, Polylineâ€¦) is created.\n            this.fireAndForward('editable:created', {layer: layer});\n            return layer;\n        },\n\n        createPolyline: function (latlngs, options) {\n            return this.createLayer(options && options.polylineClass || this.options.polylineClass, latlngs, options);\n        },\n\n        createPolygon: function (latlngs, options) {\n            return this.createLayer(options && options.polygonClass || this.options.polygonClass, latlngs, options);\n        },\n\n        createMarker: function (latlng, options) {\n            return this.createLayer(options && options.markerClass || this.options.markerClass, latlng, options);\n        },\n\n        createRectangle: function (bounds, options) {\n            return this.createLayer(options && options.rectangleClass || this.options.rectangleClass, bounds, options);\n        },\n\n        createCircle: function (latlng, options) {\n            return this.createLayer(options && options.circleClass || this.options.circleClass, latlng, options);\n        }\n\n    });\n\n    L.extend(L.Editable, {\n\n        makeCancellable: function (e) {\n            e.cancel = function () {\n                e._cancelled = true;\n            };\n        }\n\n    });\n\n    // ðŸ‚namespace Map; ðŸ‚class Map\n    // Leaflet.Editable add options and events to the `L.Map` object.\n    // See `Editable` events for the list of events fired on the Map.\n    // ðŸ‚example\n    //\n    // ```js\n    // var map = L.map('map', {\n    //  editable: true,\n    //  editOptions: {\n    //    â€¦\n    // }\n    // });\n    // ```\n    // ðŸ‚section Editable Map Options\n    L.Map.mergeOptions({\n\n        // ðŸ‚namespace Map\n        // ðŸ‚section Map Options\n        // ðŸ‚option editToolsClass: class = L.Editable\n        // Class to be used as vertex, for path editing.\n        editToolsClass: L.Editable,\n\n        // ðŸ‚option editable: boolean = false\n        // Whether to create a L.Editable instance at map init.\n        editable: false,\n\n        // ðŸ‚option editOptions: hash = {}\n        // Options to pass to L.Editable when instanciating.\n        editOptions: {}\n\n    });\n\n    L.Map.addInitHook(function () {\n\n        this.whenReady(function () {\n            if (this.options.editable) {\n                this.editTools = new this.options.editToolsClass(this, this.options.editOptions);\n            }\n        });\n\n    });\n\n    L.Editable.VertexIcon = L.DivIcon.extend({\n\n        options: {\n            iconSize: new L.Point(8, 8)\n        }\n\n    });\n\n    L.Editable.TouchVertexIcon = L.Editable.VertexIcon.extend({\n\n        options: {\n            iconSize: new L.Point(20, 20)\n        }\n\n    });\n\n\n    // ðŸ‚namespace Editable; ðŸ‚class VertexMarker; Handler for dragging path vertices.\n    L.Editable.VertexMarker = L.Marker.extend({\n\n        options: {\n            draggable: true,\n            className: 'leaflet-div-icon leaflet-vertex-icon'\n        },\n\n\n        // ðŸ‚section Public methods\n        // The marker used to handle path vertex. You will usually interact with a `VertexMarker`\n        // instance when listening for events like `editable:vertex:ctrlclick`.\n\n        initialize: function (latlng, latlngs, editor, options) {\n            // We don't use this._latlng, because on drag Leaflet replace it while\n            // we want to keep reference.\n            this.latlng = latlng;\n            this.latlngs = latlngs;\n            this.editor = editor;\n            L.Marker.prototype.initialize.call(this, latlng, options);\n            this.options.icon = this.editor.tools.createVertexIcon({className: this.options.className});\n            this.latlng.__vertex = this;\n            this.editor.editLayer.addLayer(this);\n            this.setZIndexOffset(editor.tools._lastZIndex + 1);\n        },\n\n        onAdd: function (map) {\n            L.Marker.prototype.onAdd.call(this, map);\n            this.on('drag', this.onDrag);\n            this.on('dragstart', this.onDragStart);\n            this.on('dragend', this.onDragEnd);\n            this.on('mouseup', this.onMouseup);\n            this.on('click', this.onClick);\n            this.on('contextmenu', this.onContextMenu);\n            this.on('mousedown touchstart', this.onMouseDown);\n            this.addMiddleMarkers();\n        },\n\n        onRemove: function (map) {\n            if (this.middleMarker) this.middleMarker.delete();\n            delete this.latlng.__vertex;\n            this.off('drag', this.onDrag);\n            this.off('dragstart', this.onDragStart);\n            this.off('dragend', this.onDragEnd);\n            this.off('mouseup', this.onMouseup);\n            this.off('click', this.onClick);\n            this.off('contextmenu', this.onContextMenu);\n            this.off('mousedown touchstart', this.onMouseDown);\n            L.Marker.prototype.onRemove.call(this, map);\n        },\n\n        onDrag: function (e) {\n            e.vertex = this;\n            this.editor.onVertexMarkerDrag(e);\n            var iconPos = L.DomUtil.getPosition(this._icon),\n                latlng = this._map.layerPointToLatLng(iconPos);\n            this.latlng.update(latlng);\n            this._latlng = this.latlng;  // Push back to Leaflet our reference.\n            this.editor.refresh();\n            if (this.middleMarker) this.middleMarker.updateLatLng();\n            var next = this.getNext();\n            if (next && next.middleMarker) next.middleMarker.updateLatLng();\n        },\n\n        onDragStart: function (e) {\n            e.vertex = this;\n            this.editor.onVertexMarkerDragStart(e);\n        },\n\n        onDragEnd: function (e) {\n            e.vertex = this;\n            this.editor.onVertexMarkerDragEnd(e);\n        },\n\n        onClick: function (e) {\n            e.vertex = this;\n            this.editor.onVertexMarkerClick(e);\n        },\n\n        onMouseup: function (e) {\n            L.DomEvent.stop(e);\n            e.vertex = this;\n            this.editor.map.fire('mouseup', e);\n        },\n\n        onContextMenu: function (e) {\n            e.vertex = this;\n            this.editor.onVertexMarkerContextMenu(e);\n        },\n\n        onMouseDown: function (e) {\n            e.vertex = this;\n            this.editor.onVertexMarkerMouseDown(e);\n        },\n\n        // ðŸ‚method delete()\n        // Delete a vertex and the related LatLng.\n        delete: function () {\n            var next = this.getNext();  // Compute before changing latlng\n            this.latlngs.splice(this.getIndex(), 1);\n            this.editor.editLayer.removeLayer(this);\n            this.editor.onVertexDeleted({latlng: this.latlng, vertex: this});\n            if (!this.latlngs.length) this.editor.deleteShape(this.latlngs);\n            if (next) next.resetMiddleMarker();\n            this.editor.refresh();\n        },\n\n        // ðŸ‚method getIndex(): int\n        // Get the index of the current vertex among others of the same LatLngs group.\n        getIndex: function () {\n            return this.latlngs.indexOf(this.latlng);\n        },\n\n        // ðŸ‚method getLastIndex(): int\n        // Get last vertex index of the LatLngs group of the current vertex.\n        getLastIndex: function () {\n            return this.latlngs.length - 1;\n        },\n\n        // ðŸ‚method getPrevious(): VertexMarker\n        // Get the previous VertexMarker in the same LatLngs group.\n        getPrevious: function () {\n            if (this.latlngs.length < 2) return;\n            var index = this.getIndex(),\n                previousIndex = index - 1;\n            if (index === 0 && this.editor.CLOSED) previousIndex = this.getLastIndex();\n            var previous = this.latlngs[previousIndex];\n            if (previous) return previous.__vertex;\n        },\n\n        // ðŸ‚method getNext(): VertexMarker\n        // Get the next VertexMarker in the same LatLngs group.\n        getNext: function () {\n            if (this.latlngs.length < 2) return;\n            var index = this.getIndex(),\n                nextIndex = index + 1;\n            if (index === this.getLastIndex() && this.editor.CLOSED) nextIndex = 0;\n            var next = this.latlngs[nextIndex];\n            if (next) return next.__vertex;\n        },\n\n        addMiddleMarker: function (previous) {\n            if (!this.editor.hasMiddleMarkers()) return;\n            previous = previous || this.getPrevious();\n            if (previous && !this.middleMarker) this.middleMarker = this.editor.addMiddleMarker(previous, this, this.latlngs, this.editor);\n        },\n\n        addMiddleMarkers: function () {\n            if (!this.editor.hasMiddleMarkers()) return;\n            var previous = this.getPrevious();\n            if (previous) this.addMiddleMarker(previous);\n            var next = this.getNext();\n            if (next) next.resetMiddleMarker();\n        },\n\n        resetMiddleMarker: function () {\n            if (this.middleMarker) this.middleMarker.delete();\n            this.addMiddleMarker();\n        },\n\n        // ðŸ‚method split()\n        // Split the vertex LatLngs group at its index, if possible.\n        split: function () {\n            if (!this.editor.splitShape) return;  // Only for PolylineEditor\n            this.editor.splitShape(this.latlngs, this.getIndex());\n        },\n\n        // ðŸ‚method continue()\n        // Continue the vertex LatLngs from this vertex. Only active for first and last vertices of a Polyline.\n        continue: function () {\n            if (!this.editor.continueBackward) return;  // Only for PolylineEditor\n            var index = this.getIndex();\n            if (index === 0) this.editor.continueBackward(this.latlngs);\n            else if (index === this.getLastIndex()) this.editor.continueForward(this.latlngs);\n        }\n\n    });\n\n    L.Editable.mergeOptions({\n\n        // ðŸ‚namespace Editable\n        // ðŸ‚option vertexMarkerClass: class = VertexMarker\n        // Class to be used as vertex, for path editing.\n        vertexMarkerClass: L.Editable.VertexMarker\n\n    });\n\n    L.Editable.MiddleMarker = L.Marker.extend({\n\n        options: {\n            opacity: 0.5,\n            className: 'leaflet-div-icon leaflet-middle-icon',\n            draggable: true\n        },\n\n        initialize: function (left, right, latlngs, editor, options) {\n            this.left = left;\n            this.right = right;\n            this.editor = editor;\n            this.latlngs = latlngs;\n            L.Marker.prototype.initialize.call(this, this.computeLatLng(), options);\n            this._opacity = this.options.opacity;\n            this.options.icon = this.editor.tools.createVertexIcon({className: this.options.className});\n            this.editor.editLayer.addLayer(this);\n            this.setVisibility();\n        },\n\n        setVisibility: function () {\n            var leftPoint = this._map.latLngToContainerPoint(this.left.latlng),\n                rightPoint = this._map.latLngToContainerPoint(this.right.latlng),\n                size = L.point(this.options.icon.options.iconSize);\n            if (leftPoint.distanceTo(rightPoint) < size.x * 3) this.hide();\n            else this.show();\n        },\n\n        show: function () {\n            this.setOpacity(this._opacity);\n        },\n\n        hide: function () {\n            this.setOpacity(0);\n        },\n\n        updateLatLng: function () {\n            this.setLatLng(this.computeLatLng());\n            this.setVisibility();\n        },\n\n        computeLatLng: function () {\n            var leftPoint = this.editor.map.latLngToContainerPoint(this.left.latlng),\n                rightPoint = this.editor.map.latLngToContainerPoint(this.right.latlng),\n                y = (leftPoint.y + rightPoint.y) / 2,\n                x = (leftPoint.x + rightPoint.x) / 2;\n            return this.editor.map.containerPointToLatLng([x, y]);\n        },\n\n        onAdd: function (map) {\n            L.Marker.prototype.onAdd.call(this, map);\n            L.DomEvent.on(this._icon, 'mousedown touchstart', this.onMouseDown, this);\n            map.on('zoomend', this.setVisibility, this);\n        },\n\n        onRemove: function (map) {\n            delete this.right.middleMarker;\n            L.DomEvent.off(this._icon, 'mousedown touchstart', this.onMouseDown, this);\n            map.off('zoomend', this.setVisibility, this);\n            L.Marker.prototype.onRemove.call(this, map);\n        },\n\n        onMouseDown: function (e) {\n            var iconPos = L.DomUtil.getPosition(this._icon),\n                latlng = this.editor.map.layerPointToLatLng(iconPos);\n            e = {\n                originalEvent: e,\n                latlng: latlng\n            };\n            if (this.options.opacity === 0) return;\n            L.Editable.makeCancellable(e);\n            this.editor.onMiddleMarkerMouseDown(e);\n            if (e._cancelled) return;\n            this.latlngs.splice(this.index(), 0, e.latlng);\n            this.editor.refresh();\n            var icon = this._icon;\n            var marker = this.editor.addVertexMarker(e.latlng, this.latlngs);\n            /* Hack to workaround browser not firing touchend when element is no more on DOM */\n            var parent = marker._icon.parentNode;\n            parent.removeChild(marker._icon);\n            marker._icon = icon;\n            parent.appendChild(marker._icon);\n            marker._initIcon();\n            marker._initInteraction();\n            marker.setOpacity(1);\n            /* End hack */\n            // Transfer ongoing dragging to real marker\n            L.Draggable._dragging = false;\n            marker.dragging._draggable._onDown(e.originalEvent);\n            this.delete();\n        },\n\n        delete: function () {\n            this.editor.editLayer.removeLayer(this);\n        },\n\n        index: function () {\n            return this.latlngs.indexOf(this.right.latlng);\n        }\n\n    });\n\n    L.Editable.mergeOptions({\n\n        // ðŸ‚namespace Editable\n        // ðŸ‚option middleMarkerClass: class = VertexMarker\n        // Class to be used as middle vertex, pulled by the user to create a new point in the middle of a path.\n        middleMarkerClass: L.Editable.MiddleMarker\n\n    });\n\n    // ðŸ‚namespace Editable; ðŸ‚class BaseEditor; ðŸ‚aka L.Editable.BaseEditor\n    // When editing a feature (Marker, Polylineâ€¦), an editor is attached to it. This\n    // editor basically knows how to handle the edition.\n    L.Editable.BaseEditor = L.Handler.extend({\n\n        initialize: function (map, feature, options) {\n            L.setOptions(this, options);\n            this.map = map;\n            this.feature = feature;\n            this.feature.editor = this;\n            this.editLayer = new L.LayerGroup();\n            this.tools = this.options.editTools || map.editTools;\n        },\n\n        // ðŸ‚method enable(): this\n        // Set up the drawing tools for the feature to be editable.\n        addHooks: function () {\n            if (this.isConnected()) this.onFeatureAdd();\n            else this.feature.once('add', this.onFeatureAdd, this);\n            this.onEnable();\n            this.feature.on(this._getEvents(), this);\n            return;\n        },\n\n        // ðŸ‚method disable(): this\n        // Remove the drawing tools for the feature.\n        removeHooks: function () {\n            this.feature.off(this._getEvents(), this);\n            if (this.feature.dragging) this.feature.dragging.disable();\n            this.editLayer.clearLayers();\n            this.tools.editLayer.removeLayer(this.editLayer);\n            this.onDisable();\n            if (this._drawing) this.cancelDrawing();\n            return;\n        },\n\n        // ðŸ‚method drawing(): boolean\n        // Return true if any drawing action is ongoing with this editor.\n        drawing: function () {\n            return !!this._drawing;\n        },\n\n        reset: function () {},\n\n        onFeatureAdd: function () {\n            this.tools.editLayer.addLayer(this.editLayer);\n            if (this.feature.dragging) this.feature.dragging.enable();\n        },\n\n        hasMiddleMarkers: function () {\n            return !this.options.skipMiddleMarkers && !this.tools.options.skipMiddleMarkers;\n        },\n\n        fireAndForward: function (type, e) {\n            e = e || {};\n            e.layer = this.feature;\n            this.feature.fire(type, e);\n            this.tools.fireAndForward(type, e);\n        },\n\n        onEnable: function () {\n            // ðŸ‚namespace Editable\n            // ðŸ‚event editable:enable: Event\n            // Fired when an existing feature is ready to be edited.\n            this.fireAndForward('editable:enable');\n        },\n\n        onDisable: function () {\n            // ðŸ‚namespace Editable\n            // ðŸ‚event editable:disable: Event\n            // Fired when an existing feature is not ready anymore to be edited.\n            this.fireAndForward('editable:disable');\n        },\n\n        onEditing: function () {\n            // ðŸ‚namespace Editable\n            // ðŸ‚event editable:editing: Event\n            // Fired as soon as any change is made to the feature geometry.\n            this.fireAndForward('editable:editing');\n        },\n\n        onStartDrawing: function () {\n            // ðŸ‚namespace Editable\n            // ðŸ‚section Drawing events\n            // ðŸ‚event editable:drawing:start: Event\n            // Fired when a feature is to be drawn.\n            this.fireAndForward('editable:drawing:start');\n        },\n\n        onEndDrawing: function () {\n            // ðŸ‚namespace Editable\n            // ðŸ‚section Drawing events\n            // ðŸ‚event editable:drawing:end: Event\n            // Fired when a feature is not drawn anymore.\n            this.fireAndForward('editable:drawing:end');\n        },\n\n        onCancelDrawing: function () {\n            // ðŸ‚namespace Editable\n            // ðŸ‚section Drawing events\n            // ðŸ‚event editable:drawing:cancel: Event\n            // Fired when user cancel drawing while a feature is being drawn.\n            this.fireAndForward('editable:drawing:cancel');\n        },\n\n        onCommitDrawing: function (e) {\n            // ðŸ‚namespace Editable\n            // ðŸ‚section Drawing events\n            // ðŸ‚event editable:drawing:commit: Event\n            // Fired when user finish drawing a feature.\n            this.fireAndForward('editable:drawing:commit', e);\n        },\n\n        onDrawingMouseDown: function (e) {\n            // ðŸ‚namespace Editable\n            // ðŸ‚section Drawing events\n            // ðŸ‚event editable:drawing:mousedown: Event\n            // Fired when user `mousedown` while drawing.\n            this.fireAndForward('editable:drawing:mousedown', e);\n        },\n\n        onDrawingMouseUp: function (e) {\n            // ðŸ‚namespace Editable\n            // ðŸ‚section Drawing events\n            // ðŸ‚event editable:drawing:mouseup: Event\n            // Fired when user `mouseup` while drawing.\n            this.fireAndForward('editable:drawing:mouseup', e);\n        },\n\n        startDrawing: function () {\n            if (!this._drawing) this._drawing = L.Editable.FORWARD;\n            this.tools.registerForDrawing(this);\n            this.onStartDrawing();\n        },\n\n        commitDrawing: function (e) {\n            this.onCommitDrawing(e);\n            this.endDrawing();\n        },\n\n        cancelDrawing: function () {\n            // If called during a vertex drag, the vertex will be removed before\n            // the mouseup fires on it. This is a workaround. Maybe better fix is\n            // To have L.Draggable reset it's status on disable (Leaflet side).\n            L.Draggable._dragging = false;\n            this.onCancelDrawing();\n            this.endDrawing();\n        },\n\n        endDrawing: function () {\n            this._drawing = false;\n            this.tools.unregisterForDrawing(this);\n            this.onEndDrawing();\n        },\n\n        onDrawingClick: function (e) {\n            if (!this.drawing()) return;\n            L.Editable.makeCancellable(e);\n            // ðŸ‚namespace Editable\n            // ðŸ‚section Drawing events\n            // ðŸ‚event editable:drawing:click: CancelableEvent\n            // Fired when user `click` while drawing, before any internal action is being processed.\n            this.fireAndForward('editable:drawing:click', e);\n            if (e._cancelled) return;\n            if (!this.isConnected()) this.connect(e);\n            this.processDrawingClick(e);\n        },\n\n        isConnected: function () {\n            return this.map.hasLayer(this.feature);\n        },\n\n        connect: function (e) {\n            this.tools.connectCreatedToMap(this.feature);\n            this.tools.editLayer.addLayer(this.editLayer);\n        },\n\n        onMove: function (e) {\n            // ðŸ‚namespace Editable\n            // ðŸ‚section Drawing events\n            // ðŸ‚event editable:drawing:move: Event\n            // Fired when `move` mouse while drawing, while dragging a marker, and while dragging a vertex.\n            this.fireAndForward('editable:drawing:move', e);\n        },\n\n        onDrawingMouseMove: function (e) {\n            this.onMove(e);\n        },\n\n        _getEvents: function () {\n            return {\n                dragstart: this.onDragStart,\n                drag: this.onDrag,\n                dragend: this.onDragEnd,\n                remove: this.disable\n            };\n        },\n\n        onDragStart: function (e) {\n            this.onEditing();\n            // ðŸ‚namespace Editable\n            // ðŸ‚event editable:dragstart: Event\n            // Fired before a path feature is dragged.\n            this.fireAndForward('editable:dragstart', e);\n        },\n\n        onDrag: function (e) {\n            this.onMove(e);\n            // ðŸ‚namespace Editable\n            // ðŸ‚event editable:drag: Event\n            // Fired when a path feature is being dragged.\n            this.fireAndForward('editable:drag', e);\n        },\n\n        onDragEnd: function (e) {\n            // ðŸ‚namespace Editable\n            // ðŸ‚event editable:dragend: Event\n            // Fired after a path feature has been dragged.\n            this.fireAndForward('editable:dragend', e);\n        }\n\n    });\n\n    // ðŸ‚namespace Editable; ðŸ‚class MarkerEditor; ðŸ‚aka L.Editable.MarkerEditor\n    // ðŸ‚inherits BaseEditor\n    // Editor for Marker.\n    L.Editable.MarkerEditor = L.Editable.BaseEditor.extend({\n\n        onDrawingMouseMove: function (e) {\n            L.Editable.BaseEditor.prototype.onDrawingMouseMove.call(this, e);\n            if (this._drawing) this.feature.setLatLng(e.latlng);\n        },\n\n        processDrawingClick: function (e) {\n            // ðŸ‚namespace Editable\n            // ðŸ‚section Drawing events\n            // ðŸ‚event editable:drawing:clicked: Event\n            // Fired when user `click` while drawing, after all internal actions.\n            this.fireAndForward('editable:drawing:clicked', e);\n            this.commitDrawing(e);\n        },\n\n        connect: function (e) {\n            // On touch, the latlng has not been updated because there is\n            // no mousemove.\n            if (e) this.feature._latlng = e.latlng;\n            L.Editable.BaseEditor.prototype.connect.call(this, e);\n        }\n\n    });\n\n    // ðŸ‚namespace Editable; ðŸ‚class PathEditor; ðŸ‚aka L.Editable.PathEditor\n    // ðŸ‚inherits BaseEditor\n    // Base class for all path editors.\n    L.Editable.PathEditor = L.Editable.BaseEditor.extend({\n\n        CLOSED: false,\n        MIN_VERTEX: 2,\n\n        addHooks: function () {\n            L.Editable.BaseEditor.prototype.addHooks.call(this);\n            if (this.feature) this.initVertexMarkers();\n            return this;\n        },\n\n        initVertexMarkers: function (latlngs) {\n            if (!this.enabled()) return;\n            latlngs = latlngs || this.getLatLngs();\n            if (L.Polyline._flat(latlngs)) this.addVertexMarkers(latlngs);\n            else for (var i = 0; i < latlngs.length; i++) this.initVertexMarkers(latlngs[i]);\n        },\n\n        getLatLngs: function () {\n            return this.feature.getLatLngs();\n        },\n\n        // ðŸ‚method reset()\n        // Rebuild edit elements (Vertex, MiddleMarker, etc.).\n        reset: function () {\n            this.editLayer.clearLayers();\n            this.initVertexMarkers();\n        },\n\n        addVertexMarker: function (latlng, latlngs) {\n            return new this.tools.options.vertexMarkerClass(latlng, latlngs, this);\n        },\n\n        addVertexMarkers: function (latlngs) {\n            for (var i = 0; i < latlngs.length; i++) {\n                this.addVertexMarker(latlngs[i], latlngs);\n            }\n        },\n\n        refreshVertexMarkers: function (latlngs) {\n            latlngs = latlngs || this.getDefaultLatLngs();\n            for (var i = 0; i < latlngs.length; i++) {\n                latlngs[i].__vertex.update();\n            }\n        },\n\n        addMiddleMarker: function (left, right, latlngs) {\n            return new this.tools.options.middleMarkerClass(left, right, latlngs, this);\n        },\n\n        onVertexMarkerClick: function (e) {\n            L.Editable.makeCancellable(e);\n            // ðŸ‚namespace Editable\n            // ðŸ‚section Vertex events\n            // ðŸ‚event editable:vertex:click: CancelableVertexEvent\n            // Fired when a `click` is issued on a vertex, before any internal action is being processed.\n            this.fireAndForward('editable:vertex:click', e);\n            if (e._cancelled) return;\n            if (this.tools.drawing() && this.tools._drawingEditor !== this) return;\n            var index = e.vertex.getIndex(), commit;\n            if (e.originalEvent.ctrlKey) {\n                this.onVertexMarkerCtrlClick(e);\n            } else if (e.originalEvent.altKey) {\n                this.onVertexMarkerAltClick(e);\n            } else if (e.originalEvent.shiftKey) {\n                this.onVertexMarkerShiftClick(e);\n            } else if (e.originalEvent.metaKey) {\n                this.onVertexMarkerMetaKeyClick(e);\n            } else if (index === e.vertex.getLastIndex() && this._drawing === L.Editable.FORWARD) {\n                if (index >= this.MIN_VERTEX - 1) commit = true;\n            } else if (index === 0 && this._drawing === L.Editable.BACKWARD && this._drawnLatLngs.length >= this.MIN_VERTEX) {\n                commit = true;\n            } else if (index === 0 && this._drawing === L.Editable.FORWARD && this._drawnLatLngs.length >= this.MIN_VERTEX && this.CLOSED) {\n                commit = true;  // Allow to close on first point also for polygons\n            } else {\n                this.onVertexRawMarkerClick(e);\n            }\n            // ðŸ‚namespace Editable\n            // ðŸ‚section Vertex events\n            // ðŸ‚event editable:vertex:clicked: VertexEvent\n            // Fired when a `click` is issued on a vertex, after all internal actions.\n            this.fireAndForward('editable:vertex:clicked', e);\n            if (commit) this.commitDrawing(e);\n        },\n\n        onVertexRawMarkerClick: function (e) {\n            // ðŸ‚namespace Editable\n            // ðŸ‚section Vertex events\n            // ðŸ‚event editable:vertex:rawclick: CancelableVertexEvent\n            // Fired when a `click` is issued on a vertex without any special key and without being in drawing mode.\n            this.fireAndForward('editable:vertex:rawclick', e);\n            if (e._cancelled) return;\n            if (!this.vertexCanBeDeleted(e.vertex)) return;\n            e.vertex.delete();\n        },\n\n        vertexCanBeDeleted: function (vertex) {\n            return vertex.latlngs.length > this.MIN_VERTEX;\n        },\n\n        onVertexDeleted: function (e) {\n            // ðŸ‚namespace Editable\n            // ðŸ‚section Vertex events\n            // ðŸ‚event editable:vertex:deleted: VertexEvent\n            // Fired after a vertex has been deleted by user.\n            this.fireAndForward('editable:vertex:deleted', e);\n        },\n\n        onVertexMarkerCtrlClick: function (e) {\n            // ðŸ‚namespace Editable\n            // ðŸ‚section Vertex events\n            // ðŸ‚event editable:vertex:ctrlclick: VertexEvent\n            // Fired when a `click` with `ctrlKey` is issued on a vertex.\n            this.fireAndForward('editable:vertex:ctrlclick', e);\n        },\n\n        onVertexMarkerShiftClick: function (e) {\n            // ðŸ‚namespace Editable\n            // ðŸ‚section Vertex events\n            // ðŸ‚event editable:vertex:shiftclick: VertexEvent\n            // Fired when a `click` with `shiftKey` is issued on a vertex.\n            this.fireAndForward('editable:vertex:shiftclick', e);\n        },\n\n        onVertexMarkerMetaKeyClick: function (e) {\n            // ðŸ‚namespace Editable\n            // ðŸ‚section Vertex events\n            // ðŸ‚event editable:vertex:metakeyclick: VertexEvent\n            // Fired when a `click` with `metaKey` is issued on a vertex.\n            this.fireAndForward('editable:vertex:metakeyclick', e);\n        },\n\n        onVertexMarkerAltClick: function (e) {\n            // ðŸ‚namespace Editable\n            // ðŸ‚section Vertex events\n            // ðŸ‚event editable:vertex:altclick: VertexEvent\n            // Fired when a `click` with `altKey` is issued on a vertex.\n            this.fireAndForward('editable:vertex:altclick', e);\n        },\n\n        onVertexMarkerContextMenu: function (e) {\n            // ðŸ‚namespace Editable\n            // ðŸ‚section Vertex events\n            // ðŸ‚event editable:vertex:contextmenu: VertexEvent\n            // Fired when a `contextmenu` is issued on a vertex.\n            this.fireAndForward('editable:vertex:contextmenu', e);\n        },\n\n        onVertexMarkerMouseDown: function (e) {\n            // ðŸ‚namespace Editable\n            // ðŸ‚section Vertex events\n            // ðŸ‚event editable:vertex:mousedown: VertexEvent\n            // Fired when user `mousedown` a vertex.\n            this.fireAndForward('editable:vertex:mousedown', e);\n        },\n\n        onMiddleMarkerMouseDown: function (e) {\n            // ðŸ‚namespace Editable\n            // ðŸ‚section MiddleMarker events\n            // ðŸ‚event editable:middlemarker:mousedown: VertexEvent\n            // Fired when user `mousedown` a middle marker.\n            this.fireAndForward('editable:middlemarker:mousedown', e);\n        },\n\n        onVertexMarkerDrag: function (e) {\n            this.onMove(e);\n            if (this.feature._bounds) this.extendBounds(e);\n            // ðŸ‚namespace Editable\n            // ðŸ‚section Vertex events\n            // ðŸ‚event editable:vertex:drag: VertexEvent\n            // Fired when a vertex is dragged by user.\n            this.fireAndForward('editable:vertex:drag', e);\n        },\n\n        onVertexMarkerDragStart: function (e) {\n            // ðŸ‚namespace Editable\n            // ðŸ‚section Vertex events\n            // ðŸ‚event editable:vertex:dragstart: VertexEvent\n            // Fired before a vertex is dragged by user.\n            this.fireAndForward('editable:vertex:dragstart', e);\n        },\n\n        onVertexMarkerDragEnd: function (e) {\n            // ðŸ‚namespace Editable\n            // ðŸ‚section Vertex events\n            // ðŸ‚event editable:vertex:dragend: VertexEvent\n            // Fired after a vertex is dragged by user.\n            this.fireAndForward('editable:vertex:dragend', e);\n        },\n\n        setDrawnLatLngs: function (latlngs) {\n            this._drawnLatLngs = latlngs || this.getDefaultLatLngs();\n        },\n\n        startDrawing: function () {\n            if (!this._drawnLatLngs) this.setDrawnLatLngs();\n            L.Editable.BaseEditor.prototype.startDrawing.call(this);\n        },\n\n        startDrawingForward: function () {\n            this.startDrawing();\n        },\n\n        endDrawing: function () {\n            this.tools.detachForwardLineGuide();\n            this.tools.detachBackwardLineGuide();\n            if (this._drawnLatLngs && this._drawnLatLngs.length < this.MIN_VERTEX) this.deleteShape(this._drawnLatLngs);\n            L.Editable.BaseEditor.prototype.endDrawing.call(this);\n            delete this._drawnLatLngs;\n        },\n\n        addLatLng: function (latlng) {\n            if (this._drawing === L.Editable.FORWARD) this._drawnLatLngs.push(latlng);\n            else this._drawnLatLngs.unshift(latlng);\n            this.feature._bounds.extend(latlng);\n            this.addVertexMarker(latlng, this._drawnLatLngs);\n            this.refresh();\n        },\n\n        newPointForward: function (latlng) {\n            this.addLatLng(latlng);\n            this.tools.attachForwardLineGuide();\n            this.tools.anchorForwardLineGuide(latlng);\n        },\n\n        newPointBackward: function (latlng) {\n            this.addLatLng(latlng);\n            this.tools.anchorBackwardLineGuide(latlng);\n        },\n\n        // ðŸ‚namespace PathEditor\n        // ðŸ‚method push()\n        // Programmatically add a point while drawing.\n        push: function (latlng) {\n            if (!latlng) return console.error('L.Editable.PathEditor.push expect a vaild latlng as parameter');\n            if (this._drawing === L.Editable.FORWARD) this.newPointForward(latlng);\n            else this.newPointBackward(latlng);\n        },\n\n        removeLatLng: function (latlng) {\n            latlng.__vertex.delete();\n            this.refresh();\n        },\n\n        // ðŸ‚method pop(): L.LatLng or null\n        // Programmatically remove last point (if any) while drawing.\n        pop: function () {\n            if (this._drawnLatLngs.length <= 1) return;\n            var latlng;\n            if (this._drawing === L.Editable.FORWARD) latlng = this._drawnLatLngs[this._drawnLatLngs.length - 1];\n            else latlng = this._drawnLatLngs[0];\n            this.removeLatLng(latlng);\n            if (this._drawing === L.Editable.FORWARD) this.tools.anchorForwardLineGuide(this._drawnLatLngs[this._drawnLatLngs.length - 1]);\n            else this.tools.anchorForwardLineGuide(this._drawnLatLngs[0]);\n            return latlng;\n        },\n\n        processDrawingClick: function (e) {\n            if (e.vertex && e.vertex.editor === this) return;\n            if (this._drawing === L.Editable.FORWARD) this.newPointForward(e.latlng);\n            else this.newPointBackward(e.latlng);\n            this.fireAndForward('editable:drawing:clicked', e);\n        },\n\n        onDrawingMouseMove: function (e) {\n            L.Editable.BaseEditor.prototype.onDrawingMouseMove.call(this, e);\n            if (this._drawing) {\n                this.tools.moveForwardLineGuide(e.latlng);\n                this.tools.moveBackwardLineGuide(e.latlng);\n            }\n        },\n\n        refresh: function () {\n            this.feature.redraw();\n            this.onEditing();\n        },\n\n        // ðŸ‚namespace PathEditor\n        // ðŸ‚method newShape(latlng?: L.LatLng)\n        // Add a new shape (Polyline, Polygon) in a multi, and setup up drawing tools to draw it;\n        // if optional `latlng` is given, start a path at this point.\n        newShape: function (latlng) {\n            var shape = this.addNewEmptyShape();\n            if (!shape) return;\n            this.setDrawnLatLngs(shape[0] || shape);  // Polygon or polyline\n            this.startDrawingForward();\n            // ðŸ‚namespace Editable\n            // ðŸ‚section Shape events\n            // ðŸ‚event editable:shape:new: ShapeEvent\n            // Fired when a new shape is created in a multi (Polygon or Polyline).\n            this.fireAndForward('editable:shape:new', {shape: shape});\n            if (latlng) this.newPointForward(latlng);\n        },\n\n        deleteShape: function (shape, latlngs) {\n            var e = {shape: shape};\n            L.Editable.makeCancellable(e);\n            // ðŸ‚namespace Editable\n            // ðŸ‚section Shape events\n            // ðŸ‚event editable:shape:delete: CancelableShapeEvent\n            // Fired before a new shape is deleted in a multi (Polygon or Polyline).\n            this.fireAndForward('editable:shape:delete', e);\n            if (e._cancelled) return;\n            shape = this._deleteShape(shape, latlngs);\n            if (this.ensureNotFlat) this.ensureNotFlat();  // Polygon.\n            this.feature.setLatLngs(this.getLatLngs());  // Force bounds reset.\n            this.refresh();\n            this.reset();\n            // ðŸ‚namespace Editable\n            // ðŸ‚section Shape events\n            // ðŸ‚event editable:shape:deleted: ShapeEvent\n            // Fired after a new shape is deleted in a multi (Polygon or Polyline).\n            this.fireAndForward('editable:shape:deleted', {shape: shape});\n            return shape;\n        },\n\n        _deleteShape: function (shape, latlngs) {\n            latlngs = latlngs || this.getLatLngs();\n            if (!latlngs.length) return;\n            var self = this,\n                inplaceDelete = function (latlngs, shape) {\n                    // Called when deleting a flat latlngs\n                    shape = latlngs.splice(0, Number.MAX_VALUE);\n                    return shape;\n                },\n                spliceDelete = function (latlngs, shape) {\n                    // Called when removing a latlngs inside an array\n                    latlngs.splice(latlngs.indexOf(shape), 1);\n                    if (!latlngs.length) self._deleteShape(latlngs);\n                    return shape;\n                };\n            if (latlngs === shape) return inplaceDelete(latlngs, shape);\n            for (var i = 0; i < latlngs.length; i++) {\n                if (latlngs[i] === shape) return spliceDelete(latlngs, shape);\n                else if (latlngs[i].indexOf(shape) !== -1) return spliceDelete(latlngs[i], shape);\n            }\n        },\n\n        // ðŸ‚namespace PathEditor\n        // ðŸ‚method deleteShapeAt(latlng: L.LatLng): Array\n        // Remove a path shape at the given `latlng`.\n        deleteShapeAt: function (latlng) {\n            var shape = this.feature.shapeAt(latlng);\n            if (shape) return this.deleteShape(shape);\n        },\n\n        // ðŸ‚method appendShape(shape: Array)\n        // Append a new shape to the Polygon or Polyline.\n        appendShape: function (shape) {\n            this.insertShape(shape);\n        },\n\n        // ðŸ‚method prependShape(shape: Array)\n        // Prepend a new shape to the Polygon or Polyline.\n        prependShape: function (shape) {\n            this.insertShape(shape, 0);\n        },\n\n        // ðŸ‚method insertShape(shape: Array, index: int)\n        // Insert a new shape to the Polygon or Polyline at given index (default is to append).\n        insertShape: function (shape, index) {\n            this.ensureMulti();\n            shape = this.formatShape(shape);\n            if (typeof index === 'undefined') index = this.feature._latlngs.length;\n            this.feature._latlngs.splice(index, 0, shape);\n            this.feature.redraw();\n            if (this._enabled) this.reset();\n        },\n\n        extendBounds: function (e) {\n            this.feature._bounds.extend(e.vertex.latlng);\n        },\n\n        onDragStart: function (e) {\n            this.editLayer.clearLayers();\n            L.Editable.BaseEditor.prototype.onDragStart.call(this, e);\n        },\n\n        onDragEnd: function (e) {\n            this.initVertexMarkers();\n            L.Editable.BaseEditor.prototype.onDragEnd.call(this, e);\n        }\n\n    });\n\n    // ðŸ‚namespace Editable; ðŸ‚class PolylineEditor; ðŸ‚aka L.Editable.PolylineEditor\n    // ðŸ‚inherits PathEditor\n    L.Editable.PolylineEditor = L.Editable.PathEditor.extend({\n\n        startDrawingBackward: function () {\n            this._drawing = L.Editable.BACKWARD;\n            this.startDrawing();\n        },\n\n        // ðŸ‚method continueBackward(latlngs?: Array)\n        // Set up drawing tools to continue the line backward.\n        continueBackward: function (latlngs) {\n            if (this.drawing()) return;\n            latlngs = latlngs || this.getDefaultLatLngs();\n            this.setDrawnLatLngs(latlngs);\n            if (latlngs.length > 0) {\n                this.tools.attachBackwardLineGuide();\n                this.tools.anchorBackwardLineGuide(latlngs[0]);\n            }\n            this.startDrawingBackward();\n        },\n\n        // ðŸ‚method continueForward(latlngs?: Array)\n        // Set up drawing tools to continue the line forward.\n        continueForward: function (latlngs) {\n            if (this.drawing()) return;\n            latlngs = latlngs || this.getDefaultLatLngs();\n            this.setDrawnLatLngs(latlngs);\n            if (latlngs.length > 0) {\n                this.tools.attachForwardLineGuide();\n                this.tools.anchorForwardLineGuide(latlngs[latlngs.length - 1]);\n            }\n            this.startDrawingForward();\n        },\n\n        getDefaultLatLngs: function (latlngs) {\n            latlngs = latlngs || this.feature._latlngs;\n            if (!latlngs.length || latlngs[0] instanceof L.LatLng) return latlngs;\n            else return this.getDefaultLatLngs(latlngs[0]);\n        },\n\n        ensureMulti: function () {\n            if (this.feature._latlngs.length && L.Polyline._flat(this.feature._latlngs)) {\n                this.feature._latlngs = [this.feature._latlngs];\n            }\n        },\n\n        addNewEmptyShape: function () {\n            if (this.feature._latlngs.length) {\n                var shape = [];\n                this.appendShape(shape);\n                return shape;\n            } else {\n                return this.feature._latlngs;\n            }\n        },\n\n        formatShape: function (shape) {\n            if (L.Polyline._flat(shape)) return shape;\n            else if (shape[0]) return this.formatShape(shape[0]);\n        },\n\n        // ðŸ‚method splitShape(latlngs?: Array, index: int)\n        // Split the given `latlngs` shape at index `index` and integrate new shape in instance `latlngs`.\n        splitShape: function (shape, index) {\n            if (!index || index >= shape.length - 1) return;\n            this.ensureMulti();\n            var shapeIndex = this.feature._latlngs.indexOf(shape);\n            if (shapeIndex === -1) return;\n            var first = shape.slice(0, index + 1),\n                second = shape.slice(index);\n            // We deal with reference, we don't want twice the same latlng around.\n            second[0] = L.latLng(second[0].lat, second[0].lng, second[0].alt);\n            this.feature._latlngs.splice(shapeIndex, 1, first, second);\n            this.refresh();\n            this.reset();\n        }\n\n    });\n\n    // ðŸ‚namespace Editable; ðŸ‚class PolygonEditor; ðŸ‚aka L.Editable.PolygonEditor\n    // ðŸ‚inherits PathEditor\n    L.Editable.PolygonEditor = L.Editable.PathEditor.extend({\n\n        CLOSED: true,\n        MIN_VERTEX: 3,\n\n        newPointForward: function (latlng) {\n            L.Editable.PathEditor.prototype.newPointForward.call(this, latlng);\n            if (!this.tools.backwardLineGuide._latlngs.length) this.tools.anchorBackwardLineGuide(latlng);\n            if (this._drawnLatLngs.length === 2) this.tools.attachBackwardLineGuide();\n        },\n\n        addNewEmptyHole: function (latlng) {\n            this.ensureNotFlat();\n            var latlngs = this.feature.shapeAt(latlng);\n            if (!latlngs) return;\n            var holes = [];\n            latlngs.push(holes);\n            return holes;\n        },\n\n        // ðŸ‚method newHole(latlng?: L.LatLng, index: int)\n        // Set up drawing tools for creating a new hole on the Polygon. If the `latlng` param is given, a first point is created.\n        newHole: function (latlng) {\n            var holes = this.addNewEmptyHole(latlng);\n            if (!holes) return;\n            this.setDrawnLatLngs(holes);\n            this.startDrawingForward();\n            if (latlng) this.newPointForward(latlng);\n        },\n\n        addNewEmptyShape: function () {\n            if (this.feature._latlngs.length && this.feature._latlngs[0].length) {\n                var shape = [];\n                this.appendShape(shape);\n                return shape;\n            } else {\n                return this.feature._latlngs;\n            }\n        },\n\n        ensureMulti: function () {\n            if (this.feature._latlngs.length && L.Polyline._flat(this.feature._latlngs[0])) {\n                this.feature._latlngs = [this.feature._latlngs];\n            }\n        },\n\n        ensureNotFlat: function () {\n            if (!this.feature._latlngs.length || L.Polyline._flat(this.feature._latlngs)) this.feature._latlngs = [this.feature._latlngs];\n        },\n\n        vertexCanBeDeleted: function (vertex) {\n            var parent = this.feature.parentShape(vertex.latlngs),\n                idx = L.Util.indexOf(parent, vertex.latlngs);\n            if (idx > 0) return true;  // Holes can be totally deleted without removing the layer itself.\n            return L.Editable.PathEditor.prototype.vertexCanBeDeleted.call(this, vertex);\n        },\n\n        getDefaultLatLngs: function () {\n            if (!this.feature._latlngs.length) this.feature._latlngs.push([]);\n            return this.feature._latlngs[0];\n        },\n\n        formatShape: function (shape) {\n            // [[1, 2], [3, 4]] => must be nested\n            // [] => must be nested\n            // [[]] => is already nested\n            if (L.Polyline._flat(shape) && (!shape[0] || shape[0].length !== 0)) return [shape];\n            else return shape;\n        }\n\n    });\n\n    // ðŸ‚namespace Editable; ðŸ‚class RectangleEditor; ðŸ‚aka L.Editable.RectangleEditor\n    // ðŸ‚inherits PathEditor\n    L.Editable.RectangleEditor = L.Editable.PathEditor.extend({\n\n        CLOSED: true,\n        MIN_VERTEX: 4,\n\n        options: {\n            skipMiddleMarkers: true\n        },\n\n        extendBounds: function (e) {\n            var index = e.vertex.getIndex(),\n                next = e.vertex.getNext(),\n                previous = e.vertex.getPrevious(),\n                oppositeIndex = (index + 2) % 4,\n                opposite = e.vertex.latlngs[oppositeIndex],\n                bounds = new L.LatLngBounds(e.latlng, opposite);\n            // Update latlngs by hand to preserve order.\n            previous.latlng.update([e.latlng.lat, opposite.lng]);\n            next.latlng.update([opposite.lat, e.latlng.lng]);\n            this.updateBounds(bounds);\n            this.refreshVertexMarkers();\n        },\n\n        onDrawingMouseDown: function (e) {\n            L.Editable.PathEditor.prototype.onDrawingMouseDown.call(this, e);\n            this.connect();\n            var latlngs = this.getDefaultLatLngs();\n            // L.Polygon._convertLatLngs removes last latlng if it equals first point,\n            // which is the case here as all latlngs are [0, 0]\n            if (latlngs.length === 3) latlngs.push(e.latlng);\n            var bounds = new L.LatLngBounds(e.latlng, e.latlng);\n            this.updateBounds(bounds);\n            this.updateLatLngs(bounds);\n            this.refresh();\n            this.reset();\n            // Stop dragging map.\n            // L.Draggable has two workflows:\n            // - mousedown => mousemove => mouseup\n            // - touchstart => touchmove => touchend\n            // Problem: L.Map.Tap does not allow us to listen to touchstart, so we only\n            // can deal with mousedown, but then when in a touch device, we are dealing with\n            // simulated events (actually simulated by L.Map.Tap), which are no more taken\n            // into account by L.Draggable.\n            // Ref.: https://github.com/Leaflet/Leaflet.Editable/issues/103\n            e.originalEvent._simulated = false;\n            this.map.dragging._draggable._onUp(e.originalEvent);\n            // Now transfer ongoing drag action to the bottom right corner.\n            // Should we refine which corne will handle the drag according to\n            // drag direction?\n            latlngs[3].__vertex.dragging._draggable._onDown(e.originalEvent);\n        },\n\n        onDrawingMouseUp: function (e) {\n            this.commitDrawing(e);\n            e.originalEvent._simulated = false;\n            L.Editable.PathEditor.prototype.onDrawingMouseUp.call(this, e);\n        },\n\n        onDrawingMouseMove: function (e) {\n            e.originalEvent._simulated = false;\n            L.Editable.PathEditor.prototype.onDrawingMouseMove.call(this, e);\n        },\n\n\n        getDefaultLatLngs: function (latlngs) {\n            return latlngs || this.feature._latlngs[0];\n        },\n\n        updateBounds: function (bounds) {\n            this.feature._bounds = bounds;\n        },\n\n        updateLatLngs: function (bounds) {\n            var latlngs = this.getDefaultLatLngs(),\n                newLatlngs = this.feature._boundsToLatLngs(bounds);\n            // Keep references.\n            for (var i = 0; i < latlngs.length; i++) {\n                latlngs[i].update(newLatlngs[i]);\n            };\n        }\n\n    });\n\n    // ðŸ‚namespace Editable; ðŸ‚class CircleEditor; ðŸ‚aka L.Editable.CircleEditor\n    // ðŸ‚inherits PathEditor\n    L.Editable.CircleEditor = L.Editable.PathEditor.extend({\n\n        MIN_VERTEX: 2,\n\n        options: {\n            skipMiddleMarkers: true\n        },\n\n        initialize: function (map, feature, options) {\n            L.Editable.PathEditor.prototype.initialize.call(this, map, feature, options);\n            this._resizeLatLng = this.computeResizeLatLng();\n        },\n\n        computeResizeLatLng: function () {\n            // While circle is not added to the map, _radius is not set.\n            var delta = (this.feature._radius || this.feature._mRadius) * Math.cos(Math.PI / 4),\n                point = this.map.project(this.feature._latlng);\n            return this.map.unproject([point.x + delta, point.y - delta]);\n        },\n\n        updateResizeLatLng: function () {\n            this._resizeLatLng.update(this.computeResizeLatLng());\n            this._resizeLatLng.__vertex.update();\n        },\n\n        getLatLngs: function () {\n            return [this.feature._latlng, this._resizeLatLng];\n        },\n\n        getDefaultLatLngs: function () {\n            return this.getLatLngs();\n        },\n\n        onVertexMarkerDrag: function (e) {\n            if (e.vertex.getIndex() === 1) this.resize(e);\n            else this.updateResizeLatLng(e);\n            L.Editable.PathEditor.prototype.onVertexMarkerDrag.call(this, e);\n        },\n\n        resize: function (e) {\n            var radius = this.feature._latlng.distanceTo(e.latlng)\n            this.feature.setRadius(radius);\n        },\n\n        onDrawingMouseDown: function (e) {\n            L.Editable.PathEditor.prototype.onDrawingMouseDown.call(this, e);\n            this._resizeLatLng.update(e.latlng);\n            this.feature._latlng.update(e.latlng);\n            this.connect();\n            // Stop dragging map.\n            e.originalEvent._simulated = false;\n            this.map.dragging._draggable._onUp(e.originalEvent);\n            // Now transfer ongoing drag action to the radius handler.\n            this._resizeLatLng.__vertex.dragging._draggable._onDown(e.originalEvent);\n        },\n\n        onDrawingMouseUp: function (e) {\n            this.commitDrawing(e);\n            e.originalEvent._simulated = false;\n            L.Editable.PathEditor.prototype.onDrawingMouseUp.call(this, e);\n        },\n\n        onDrawingMouseMove: function (e) {\n            e.originalEvent._simulated = false;\n            L.Editable.PathEditor.prototype.onDrawingMouseMove.call(this, e);\n        },\n\n        onDrag: function (e) {\n            L.Editable.PathEditor.prototype.onDrag.call(this, e);\n            this.feature.dragging.updateLatLng(this._resizeLatLng);\n        }\n\n    });\n\n    // ðŸ‚namespace Editable; ðŸ‚class EditableMixin\n    // `EditableMixin` is included to `L.Polyline`, `L.Polygon`, `L.Rectangle`, `L.Circle`\n    //Â and `L.Marker`. It adds some methods to them.\n    // *When editing is enabled, the editor is accessible on the instance with the\n    // `editor` property.*\n    var EditableMixin = {\n\n        createEditor: function (map) {\n            map = map || this._map;\n            var tools = (this.options.editOptions || {}).editTools || map.editTools;\n            if (!tools) throw Error('Unable to detect Editable instance.')\n            var Klass = this.options.editorClass || this.getEditorClass(tools);\n            return new Klass(map, this, this.options.editOptions);\n        },\n\n        // ðŸ‚method enableEdit(map?: L.Map): this.editor\n        // Enable editing, by creating an editor if not existing, and then calling `enable` on it.\n        enableEdit: function (map) {\n            if (!this.editor) this.createEditor(map);\n            this.editor.enable();\n            return this.editor;\n        },\n\n        // ðŸ‚method editEnabled(): boolean\n        // Return true if current instance has an editor attached, and this editor is enabled.\n        editEnabled: function () {\n            return this.editor && this.editor.enabled();\n        },\n\n        // ðŸ‚method disableEdit()\n        // Disable editing, also remove the editor property reference.\n        disableEdit: function () {\n            if (this.editor) {\n                this.editor.disable();\n                delete this.editor;\n            }\n        },\n\n        // ðŸ‚method toggleEdit()\n        // Enable or disable editing, according to current status.\n        toggleEdit: function () {\n            if (this.editEnabled()) this.disableEdit();\n            else this.enableEdit();\n        },\n\n        _onEditableAdd: function () {\n            if (this.editor) this.enableEdit();\n        }\n\n    };\n\n    var PolylineMixin = {\n\n        getEditorClass: function (tools) {\n            return (tools && tools.options.polylineEditorClass) ? tools.options.polylineEditorClass : L.Editable.PolylineEditor;\n        },\n\n        shapeAt: function (latlng, latlngs) {\n            // We can have those cases:\n            // - latlngs are just a flat array of latlngs, use this\n            // - latlngs is an array of arrays of latlngs, loop over\n            var shape = null;\n            latlngs = latlngs || this._latlngs;\n            if (!latlngs.length) return shape;\n            else if (L.Polyline._flat(latlngs) && this.isInLatLngs(latlng, latlngs)) shape = latlngs;\n            else for (var i = 0; i < latlngs.length; i++) if (this.isInLatLngs(latlng, latlngs[i])) return latlngs[i];\n            return shape;\n        },\n\n        isInLatLngs: function (l, latlngs) {\n            if (!latlngs) return false;\n            var i, k, len, part = [], p,\n                w = this._clickTolerance();\n            this._projectLatlngs(latlngs, part, this._pxBounds);\n            part = part[0];\n            p = this._map.latLngToLayerPoint(l);\n\n            if (!this._pxBounds.contains(p)) { return false; }\n            for (i = 1, len = part.length, k = 0; i < len; k = i++) {\n\n                if (L.LineUtil.pointToSegmentDistance(p, part[k], part[i]) <= w) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n    };\n\n    var PolygonMixin = {\n\n        getEditorClass: function (tools) {\n            return (tools && tools.options.polygonEditorClass) ? tools.options.polygonEditorClass : L.Editable.PolygonEditor;\n        },\n\n        shapeAt: function (latlng, latlngs) {\n            // We can have those cases:\n            // - latlngs are just a flat array of latlngs, use this\n            // - latlngs is an array of arrays of latlngs, this is a simple polygon (maybe with holes), use the first\n            // - latlngs is an array of arrays of arrays, this is a multi, loop over\n            var shape = null;\n            latlngs = latlngs || this._latlngs;\n            if (!latlngs.length) return shape;\n            else if (L.Polyline._flat(latlngs) && this.isInLatLngs(latlng, latlngs)) shape = latlngs;\n            else if (L.Polyline._flat(latlngs[0]) && this.isInLatLngs(latlng, latlngs[0])) shape = latlngs;\n            else for (var i = 0; i < latlngs.length; i++) if (this.isInLatLngs(latlng, latlngs[i][0])) return latlngs[i];\n            return shape;\n        },\n\n        isInLatLngs: function (l, latlngs) {\n            var inside = false, l1, l2, j, k, len2;\n\n            for (j = 0, len2 = latlngs.length, k = len2 - 1; j < len2; k = j++) {\n                l1 = latlngs[j];\n                l2 = latlngs[k];\n\n                if (((l1.lat > l.lat) !== (l2.lat > l.lat)) &&\n                        (l.lng < (l2.lng - l1.lng) * (l.lat - l1.lat) / (l2.lat - l1.lat) + l1.lng)) {\n                    inside = !inside;\n                }\n            }\n\n            return inside;\n        },\n\n        parentShape: function (shape, latlngs) {\n            latlngs = latlngs || this._latlngs;\n            if (!latlngs) return;\n            var idx = L.Util.indexOf(latlngs, shape);\n            if (idx !== -1) return latlngs;\n            for (var i = 0; i < latlngs.length; i++) {\n                idx = L.Util.indexOf(latlngs[i], shape);\n                if (idx !== -1) return latlngs[i];\n            }\n        }\n\n    };\n\n\n    var MarkerMixin = {\n\n        getEditorClass: function (tools) {\n            return (tools && tools.options.markerEditorClass) ? tools.options.markerEditorClass : L.Editable.MarkerEditor;\n        }\n\n    };\n\n    var RectangleMixin = {\n\n        getEditorClass: function (tools) {\n            return (tools && tools.options.rectangleEditorClass) ? tools.options.rectangleEditorClass : L.Editable.RectangleEditor;\n        }\n\n    };\n\n    var CircleMixin = {\n\n        getEditorClass: function (tools) {\n            return (tools && tools.options.circleEditorClass) ? tools.options.circleEditorClass : L.Editable.CircleEditor;\n        }\n\n    };\n\n    var keepEditable = function () {\n        // Make sure you can remove/readd an editable layer.\n        this.on('add', this._onEditableAdd);\n    };\n\n\n\n    if (L.Polyline) {\n        L.Polyline.include(EditableMixin);\n        L.Polyline.include(PolylineMixin);\n        L.Polyline.addInitHook(keepEditable);\n    }\n    if (L.Polygon) {\n        L.Polygon.include(EditableMixin);\n        L.Polygon.include(PolygonMixin);\n    }\n    if (L.Marker) {\n        L.Marker.include(EditableMixin);\n        L.Marker.include(MarkerMixin);\n        L.Marker.addInitHook(keepEditable);\n    }\n    if (L.Rectangle) {\n        L.Rectangle.include(EditableMixin);\n        L.Rectangle.include(RectangleMixin);\n    }\n    if (L.Circle) {\n        L.Circle.include(EditableMixin);\n        L.Circle.include(CircleMixin);\n    }\n\n    L.LatLng.prototype.update = function (latlng) {\n        latlng = L.latLng(latlng);\n        this.lat = latlng.lat;\n        this.lng = latlng.lng;\n    }\n\n}, window));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/leaflet-editable/src/Leaflet.Editable.js\n// module id = 2\n// module chunks = 0","'use strict';\n\n/* A Draggable that does not update the element position\nand takes care of only bubbling to targetted path in Canvas mode. */\nL.PathDraggable = L.Draggable.extend({\n\n  initialize: function (path) {\n    this._path = path;\n    this._canvas = (path._map.getRenderer(path) instanceof L.Canvas);\n    var element = this._canvas ? this._path._map.getRenderer(this._path)._container : this._path._path;\n    L.Draggable.prototype.initialize.call(this, element, element, true);\n  },\n\n  _updatePosition: function () {\n    var e = {originalEvent: this._lastEvent};\n    this.fire('drag', e);\n  },\n\n  _onDown: function (e) {\n    var first = e.touches ? e.touches[0] : e;\n    this._startPoint = new L.Point(first.clientX, first.clientY);\n    if (this._canvas && !this._path._containsPoint(this._path._map.mouseEventToLayerPoint(first))) { return; }\n    L.Draggable.prototype._onDown.call(this, e);\n  }\n\n});\n\n\nL.Handler.PathDrag = L.Handler.extend({\n\n  initialize: function (path) {\n    this._path = path;\n  },\n\n  getEvents: function () {\n    return {\n      dragstart: this._onDragStart,\n      drag: this._onDrag,\n      dragend: this._onDragEnd\n    };\n  },\n\n  addHooks: function () {\n    if (!this._draggable) { this._draggable = new L.PathDraggable(this._path); }\n    this._draggable.on(this.getEvents(), this).enable();\n    L.DomUtil.addClass(this._draggable._element, 'leaflet-path-draggable');\n  },\n\n  removeHooks: function () {\n    this._draggable.off(this.getEvents(), this).disable();\n    L.DomUtil.removeClass(this._draggable._element, 'leaflet-path-draggable');\n  },\n\n  moved: function () {\n    return this._draggable && this._draggable._moved;\n  },\n\n  _onDragStart: function () {\n    this._startPoint = this._draggable._startPoint;\n    this._path\n        .closePopup()\n        .fire('movestart')\n        .fire('dragstart');\n  },\n\n  _onDrag: function (e) {\n    var path = this._path,\n        event = (e.originalEvent.touches && e.originalEvent.touches.length === 1 ? e.originalEvent.touches[0] : e.originalEvent),\n        newPoint = L.point(event.clientX, event.clientY),\n        latlng = path._map.layerPointToLatLng(newPoint);\n\n    this._offset = newPoint.subtract(this._startPoint);\n    this._startPoint = newPoint;\n\n    this._path.eachLatLng(this.updateLatLng, this);\n    path.redraw();\n\n    e.latlng = latlng;\n    e.offset = this._offset;\n    path.fire('move', e)\n        .fire('drag', e);\n  },\n\n  _onDragEnd: function (e) {\n    if (this._path._bounds) this.resetBounds();\n    this._path.fire('moveend')\n        .fire('dragend', e);\n  },\n\n  latLngToLayerPoint: function (latlng) {\n    // Same as map.latLngToLayerPoint, but without the round().\n    var projectedPoint = this._path._map.project(L.latLng(latlng));\n    return projectedPoint._subtract(this._path._map.getPixelOrigin());\n  },\n\n  updateLatLng: function (latlng) {\n    var oldPoint = this.latLngToLayerPoint(latlng);\n    oldPoint._add(this._offset);\n    var newLatLng = this._path._map.layerPointToLatLng(oldPoint);\n    latlng.lat = newLatLng.lat;\n    latlng.lng = newLatLng.lng;\n  },\n\n  resetBounds: function () {\n    this._path._bounds = new L.LatLngBounds();\n    this._path.eachLatLng(function (latlng) {\n      this._bounds.extend(latlng);\n    });\n  }\n\n});\n\nL.Path.include({\n\n  eachLatLng: function (callback, context) {\n    context = context || this;\n    var loop = function (latlngs) {\n      for (var i = 0; i < latlngs.length; i++) {\n        if (L.Util.isArray(latlngs[i])) loop(latlngs[i]);\n        else callback.call(context, latlngs[i]);\n      }\n    };\n    loop(this.getLatLngs ? this.getLatLngs() : [this.getLatLng()]);\n  }\n\n});\n\nL.Path.addInitHook(function () {\n\n  this.dragging = new L.Handler.PathDrag(this);\n  if (this.options.draggable) {\n    this.once('add', function () {\n      this.dragging.enable();\n    });\n  }\n\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/leaflet.path.drag/src/Path.Drag.js\n// module id = 3\n// module chunks = 0"],"sourceRoot":""}